<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <link rel="stylesheet" href="../style/nyelvek.css">
    <title>Angular</title>
</head>
<body>
  <nav class="navbar navbar-expand-xl navbar-dark navbar-bg">
    <div class="container-fluid col-lg-8 col-md-10 col-sm-12">
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarTogglerDemo02" aria-controls="navbarTogglerDemo02" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarTogglerDemo02">
        <!--Az első négy gomb bal oldalra zárva - ezek külön ul-ben vannak-->
        <ul class="navbar-nav me-auto mb-2 mb-lg-0">
          <li class="nav-item dropdown"><a class="nav-link" href="html.html">HTML</a></li>
          <li class="nav-item dropdown"><a class="nav-link" href="css.html">CSS</a></li>
          <li class="nav-item dropdown"><a class="nav-link" href="js.html">JS</a></li>
          <li class="nav-item dropdown"><a class="nav-link" href="ts.html">TS</a></li>
          <li class="nav-item dropdown"><a class="nav-link" href="mysql.html">MySQL</a></li>
          <li class="nav-item dropdown"><a class="nav-link" href="nodejs.html">NodeJS</a></li>
          <li class="nav-item dropdown"><a class="nav-link active disabled" href="angular.html">Angular</a></li>
        </ul>
        <!--Az érdekességek lenyíló lista jobb oldalra zárva, ez is külön ul-ben van-->
        <ul class="navbar-nav ms-auto mb-2 mb-lg-0">
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown04" role="button" data-bs-toggle="dropdown" aria-expanded="false">
              Érdekesség
            </a>
            <ul class="dropdown-menu dropdown-bg" aria-labelledby="navbarDropdown04">
              
            </ul>
          </li>
        </ul>
      </div>
    </div>
  </nav>

  <div id="content-container" class="container-fluid col-lg-8 col-md-10 col-sm-12">
    <div>
        <h1>Angular</h1>
        <h2>Az oldal tartalma</h2>
        <ol>
            <li><a href="#cli-kodok">CLI kódok</a></li>
            <li><a href="#bevezetes">Bevezetés</a></li>
            <li><a href="#komponensek-alapok">Alapok - komponensek</a></li>
            <li><a href="#databinding-alapok">Alapok - databinding</a></li>
            <li><a href="#directives-alapok">Alapok - directives</a></li>
            <li><a href="#kiegeszitesek-alapok">Alapok - kiegészítések</a></li>
            <li><a href="#course-project-alapok">Alapok - Course Project rövid összefoglaló</a></li>
            <li><a href="#deep-dive">Components & databinding deep dive</a></li>
            <li><a href="#course-project-komponensek">Komponensek - Course Project rövid összefoglaló</a></li>
            <li><a href="#directives-deep-dive">Directives deep dive</a></li>
            <li><a href="#services">Services & Dependency Injection</a></li>
            <li><a href="#routing">Routing</a></li>
            <li><a href="#course-project-routing">Routing összefoglaló</a></li>
        </ol>
    </div>

    <div id="cli-kodok">
      <h2>CLI kódok</h2>
    </div>

    <div id="bevezetes">
      <h2>Bevezetés</h2>
      <p>Telepítés: npm install -g @angular/cli@latest <br>
        Új projekt készítése: ng new {fájlnév} <br>
        Szerver futtatása a mappán belül: ng serve <br>
        App futtatása: általában localhost:4200</p>
      <p>fájl/src/app/ mappában találhatóak a nekünk szükséges fájlok</p>
      <p>app.component.html-ben található a html fájl, amit tudunk szerkesztgetni <br>
        app.component.css-ben a stílust tudjuk megadni <br>
        app.component.ts-ben pedig kezdetben meg van adva a Component (ez exportálva van). Itt tudunk létrehozni komponenseket.</p>
      <p>Ha azt szeretnénk, hogy egy input text mezőben lévő szöveg dinamikusan változzon a honlapon, akkor a következőt kell megadni: <br>
        &ltinput type="text" [(ngModel)]="name"&gt</p>
      <p>Ehhez viszont két dolgot kell megadni: </p>
      <ol>
        <li>Az app.component.ts fájlban az AppComponentnél definiálni kell a name változót <br>
        <img src="../img/angular/Kép1.jpg" alt=""></li>
        <li>Az app.module.ts-ben importálni kell a FormsModulet, ugyanis az ngModel TS alapú, amit fel kell ismernie az Angularnak: import { FormsModule } from '@angular/forms' <br>
        <img src="../img/angular/Kép2.jpg" alt=""></li>
        <li>Ezután az @NgModule-on belül az importhoz hozzá kell írni a FormsModulet. <br>
        <img src="../img/angular/Kép3.jpg" alt=""></li>
      </ol>
      <p>Projekten belül adjuk hozzá a bootstrapet: npm install --save bootstrap</p>
      <p>A projekten belül található angular.json-ben keressük meg a stylest. Itt adjuk meg a "src/styles.css" mellett azt, hogy "node_modules/bootstrap/dist/css/bootstrap.min.css" <br>
        <img src="../img/angular/Kép4.jpg" alt=""></p>
    </div>

    <div id="komponensek-alapok">
      <h2>Alapok - komponensek</h2>
      <ol>
        <li>Az app mappában található app.component.ts-ben kell megadni a komponenseket.</li>
        <li>Ezek az app.moduleban található bootstrap: [AppComponent] segítségével kiolvasásra kerülnek, amit később az Angular már tud értelmezni.</li>
        <li>Az értelmezéshez importálni kell az AppModule-t a main.ts fájlban.</li>
        <li>Így, az index.html-ben található app-root tag is értelmezésre kerül, holott ez nem egy standard HTML tag. <br>
        <img src="../img/angular/Kép5.jpg" alt=""></li>
      </ol>
      <p>A komponensek célja az, hogy a weboldalunkat több különböző komponensre bontsuk szét, amelyek önálló templatetel rendelkeznek. Ezáltal a különböző komponensek újrafelhasználhatóak lehetnek, valamint mivel külön templatetel rendelkeznek, így sokkal átláthatóbbá tudjuk tenni a projektet, ami, különösen a komplex weboldalak esetén, igencsak fontos!</p>
      <h3>Komponensek készítése (manuálisan):</h3>
      <ol>
        <li>Készítsünk egy új mappát az app mappán belül. Azért az app mappán belül, mert egy Angular projektben a lényegi információk az app mappában találhatóak.</li>
        <li>A mappát célszerű úgy elnevezni, mint a komponenst.</li>
        <li>Hozzuk létre a mappán belül a {komponens név}.component.ts fájlt.</li>
        <li>A TS fájlban adjuk meg ezt, természetesen a megfelelő komponensnév felhasználásával: <br>
          <img src="../img/angular/Kép6.jpg" alt=""></li>
        <li>Az app.module.ts fájlban adjuk hozzá a declarations-höz az új componensünket, amit feljebb megadtunk. Ahhoz, hogy ez valid legyen, importálni kell az osztályt: import { ServerComponent } from './server/server.component';</li>
      </ol>
      <p>CLI-jal komponens generálása: ng generate component {komponens neve} vagy ng g c {komponens neve}</p>
      <p>Ha nem az app, hanem más mappába szeretnénk létrehozni a komponenst, akkor útvonalat kell megadni: ng g c útvonal/{komponens neve}</komponens></p>
      <p>Ha a selectornál nem simán adjuk meg a nevet, hanem kapcsos zárójelek között (pl. '[app-servers]'), akkor úgy adtunk meg, hogy az egy element. Ilyenkor csak akkor tudjuk használni a komponenst, ha úgy adjuk meg, hogy: <br>
        &ltdiv app-servers&gt&lt/div&gt</p>
      <p>Ha pedig pontot teszünk a név elé (pl. '.app-servers'), akkor osztályként tekintünk rá. Ahhoz, hogy használni tudjuk a komponenst, a következőt kell megadni: <br>
        &ltdiv class="app-servers"&gt&lt/div&gt</p>
    </div>

    <div id="databinding-alapok">
      <h2>Alapok - Databinding</h2>
      <h3>1. String interpolation</h3>
      <p>Adjuk meg export class ...Componentnél azokat a komponenseket, amiket dinamikusan szeretnénk kiíratni.</p>
      <p>Ezután a html fájlban {{ }} között adjuk meg a komponens nevét. <br>
        <img src="../img/angular/Kép7.jpg" alt=""></p>
      <p>Vagy a {{ }} jelek közé megadhatunk stringet is akár. A lényeg, hogy különböző blokkokat, mint pl elágazás, nem adhatunk meg!</p>
      <p>De akár definiálhatunk metódust is az osztályon belül, <br>
        <img src="../img/angular/Kép8.jpg" alt=""> <br>
        amit fel tudunk használni dinamikusan: <br>
        <img src="../img/angular/Kép9.jpg" alt=""></p>
      <h3>2. Property binding</h3>
      <p>Különböző HTML elemek propertyjét tudjuk dinamikusan változtatni vele, mint például a button disabled propertyjét. Ehhez az angular OnInit könyvtárát kell importálni és használni. A propertyket, amikre szeretnénk hatással lenni, [] közé kell tenni és értéket kell neki adni "" közé, ami lehet változónév vagy konkrét érték. <br>
        <img src="../img/angular/Kép10.jpg" alt=""></p>
      <p>Használjunk string interpolationt, ha az outputot szeretnénk dinamikusan változtatni és property bindingot, ha HTML elemek propertyjét szeretnénk.</p>
      <h3>3. Event listener</h3>
      <p>Normál esetben, ha azt szeretnénk, hogy kattintásra történjen valami, akkor az onclick-et kell megadni. Angularban viszont ennél egyszerűbb módszert tudunk használni: ({event}) = "{metódus/függvény}". <br>
        <img src="../img/angular/Kép11.jpg" alt=""> <br>
        <img src="../img/angular/Kép12.jpg" alt=""> <br></p>
      <p>$event - akkor kell, ha szeretnénk megkapni azokat az adatokat, amik az event során keletkeznek vagy változnak. <br>
        <img src="../img/angular/Kép13.jpg" alt=""></p>
      <h3>4. Two-way binding</h3>
      <p>A two-way binding esetében a komponensek a különböző evenetek hatására dinamikusan változtatják meg értékeiket. Ehhez kell használni a fent említett [(ngModel)]-t. <br>
        A lényegi különbség a two-way binding és az event listener között az, hogyha az event listenernél történik értékváltoztatás, akkor a two-way binding is képes átvenni az adott értéket, viszont ez fordítva nem igaz: ha például olyan input mezőben változtatunk meg értéket, ahol two-way binding van, akkor az event listener mezőjében nem lesz semmilyen változás. <br>
        <img src="../img/angular/Kép14.jpg" alt=""></p>
      <p>A használatához ne felejtsük el az app.module.ts fájlban megadni a FormsModule-t. Bővebben lásd: <a href="#bevezetes">bevezetés</a>.</p>
    </div>

    <div id="directives-alapok">
      <h2>Alapok - directives</h2>
      <p>A directivek olyan osztályok, amik újabb viselkedést adnak HTML elemekhez.</p>
      <p>Built-in directivek:</p>
      <ul style="list-style: none;">
        <li>* - struktúrális directive - módosítja a DOM-ot.</li>
        <li>[] - property binding</li>
      </ul>
      <p>1. *ngIf - elágazás, akkor célszerű használni, ha valamit ki szeretnénk dinamikusan iratni vagy sem <br>
        <img src="../img/angular/Kép15.jpg" alt=""></p>
      <p>2. Else ág: else ágat az alábbiak szerint tudunk megadni ngIf-fel: <br>
        <img src="../img/angular/Kép16.jpg" alt=""></p>
      <p>Itt a #noServerrel megjelöljük azt a részt, amit meg szeretnénk adni az else ágban.</p>
      <p>3. [ngStyle] - dinamikusan tudunk stílust megadni, a CSS propertyket camelCaseként kell megadni <br>
        <img src="../img/angular/Kép17.jpg" alt=""></p>
      <p>A CSS propertyket megadhatjuk camelCase-szel vagy idézőjelek között is.</p>
      <p>4. [ngClass] = CSS osztályok dinamikus hozzáadása és elvétele <br>
        <img src="../img/angular/Kép18.jpg" alt=""></p>
      <p>5. *ngFor - listák kiíratása <br>
        <img src="../img/angular/Kép19.jpg" alt=""></p>
      <p>Általánosan: var/let/const + egy random név + of + a tömbünk.</p>
      <p>Toggling: (click)="showSecret = !showSecret"</p>
    </div>

    <div id="kiegeszitesek-alapok">
      <h2>Alapok - kiegészítések</h2>
      <p>&ltkomponens&gt.model.ts -> osztályok létrehozására szolgál</p>
    </div>

    <div id="course-project-alapok">
      <h2>Alapok - Course Project rövid összefoglaló</h2>
      <ol>
        <li>Tervezzük meg az applikációt, gondoljuk át, hogy milyen feature-öket, komponenseket és modelleket szeretnénk használni. Ezeket a későbbiekben is lehet módosítani, illetve bővíteni! A modellek alatt azt értjük, amikor valamit gyakran használjuk és a jellemzőik megegyeznek. Vagyis tulajdonképpen létrehozunk egy osztályt modell címszó alatt.</li>
        <li>Tervezzük meg azt, hogy milyen hiearchiában szerepelnek a komponensek és az alapján hozzuk létre az összes komponenst CLI-val az ng g c {komponens} paranccsal. Ha kell, adjunk meg útvonalat is.</li>
        <li>Tervezzük meg, hogy az egyes komponensek hogyan helyezkedjenek el a honlapon. Gondoljuk át, hogy minek mekkora helyet kell foglalnia és alakítsuk ki az összes komponens elhelyezkedését. Közben teszteljük azt tesztadatokkal, hogy valóban megfelel-e a várakozásnak az elrendezés.</li>
        <li>Célszerű a headerrel kezdeni (ha van), mert az az egyik legegyszerűbb. Utána sorban következik a többi komponens. Ne felejtsük el, hogy ahhoz, hogy megjelenjen egy komponens a weboldalon, használni kell a komponenshez tartozó taget (pl app-recipes)!</li>
        <li>Ahol kell, ott hozzunk létre modelleket és azon belül is osztályokat, ehhez az export class kifejezést kell használni. Ezeknél az osztályoknál adjuk meg a jellemzőket típusozva és a constructor() metódusban inicializáljuk az adatokat (ne felejtsük el, hogy this-t kell használni!). Ott, ahol a későbbiekben használjuk az osztályokat, ott be is kell importálni azt, illetve egy tömböt is létre kell hozni, amelynek a típusa az az osztály lesz, amit létrehoztunk (+ []). Új objektumot a new {class}() segítségével tudunk létrehozni, ahol a zárójelen belül annyi értéket kell megadni (a típusoknak megfelelően), ahány jellemzője van az adott osztálynak. Ha nem teljesül, hibaüzenetet kapunk.</li>
        <li>A komponenseket úgy építsük fel, hogy ahol tömböt használunk és dinamikusan íratnánk ki az adatokat, ott</li>
        <ul style="list-style: lower-alpha;">
          <li>megfelelően lehessen használni az *ngFor-t és</li>
          <li>megfelelő helyre be is tudjuk illeszteni az adatot string interpolationnal vagy property bindinggal. Mivel objektumokat használunk, így az objektum jellemzőjére tudunk hivatkozni.</li>
        </ul>
        <li>Általánosan: alakítsuk ki az összes komponenst, amit létrehoztunk, finomhangolni később is lehet. Ami a legfontosabb, hogy a hiearchiára ügyelni kell!</li>
      </ol>
    </div>

    <div id="deep-dive">
      <h2>Components & databinding deep dive</h2>
      <p>Dokumentáció (input-output): <a href="https://angular.io/guide/inputs-outputs">[Angular]</a></p>
      <h3>Input</h3>
      <p>Nagyon fontos, hogy a komponensek propertyjei alapesetben csak az adott komponensben érhetőek el! Ahhoz, hogy egy propertyt elérhessünk a szülő komponensben, a property elé meg kell adni a @Input() decoratort és ezt az Inputot importálni kell a @angular/coreból! A zárójelek közé az aliast kell írni, hogy milyen néven szeretnénk azt a propertyt használni a komponensen kívül. Ebben az esetben a szülő komponenstől áramlik az adat a gyerek komponens felé. <br>
        <img src="../img/angular/Kép20.jpg" alt=""> <br>
        Az adatokat property bindinggal tudjuk továbbítani. Például: [number]="oddNumber", ahol number az a property, ami a gyerek komponensben is szerepel.</p>
      <h3>Output</h3>
      <p>Ahhoz, hogy egy szülő komponensben végrehajtódjon egy folyamat, például tömbhöz hozzáadás, különböző eventeket kell létrehozni. Ezeket az eventeket hasonló nevű metódusokhoz kapcsoljuk a szülő komponensben, mint ahogy a gyerek komponensben is tettük (pl. (serverCreated)="onServerAdded($event)"). <br>
        A metódusnál zárójelben egy olyan objektumot kell megadnunk, ami tartalmazza az összes olyan propertyt, amit át szeretnénk venni a gyerek komponenstől. Ezután a gyerek komponensben, az event nevének megfelelő propertyket hozunk létre, melyhez a new EventEmitter&lt&gt értéket rendeljük. Ennek segítségével tud bekövetkezni az az event, amit szeretnénk. <br>
        A &lt&gt-n belül azt az objektumot kell megadni, amit a szülő komponens megfelelő metódusaiban is megadtunk. <br>
        <img src="../img/angular/Kép21.jpg" alt=""> <br>
        Ezután az osztály megfelelő metódusain belül meghívjuk az emit metódust méghozzá úgy, hogyha mondjuk az event neve serverCreated, akkor a metóduson belül ezt kell megadni: this.serverCreated.emit({}). Ezután, mivel a gyerek komponensből küldünk adatokat a szülő komponens felé, @Output()-t kell az eventek neve elé írni és ezt is importálni kell a @angular/coreból! Hasonlóan a () belül meg tudunk adni egy aliast. <br>
        <img src="../img/angular/Kép22.jpg" alt=""></p>
      <p>Ez utóbbira példa lépésről lépésre:</p>
      <ol>
        <li>A szülő komponensben a gyerek komponenshez tartozó "HTML" tagben adjuk meg az eventet, például ezt: (serverCreated)="onServerAdded($event)". A gyerek komponensben a hasonló nevű metódus az onAddServer nevet viseli.</li>
        <li>A komponens TS fájljában definiáljuk ezt a metódust és a zárójelben egy olyan objektumot adjunk meg, amilyen értékeket szeretnénk átvenni a gyerek komponenstől. <br>
          onServerAdded(serverData: {serverName: string, serverContent: string})</li>
        <li>A gyerek komponensben, az event nevének megfelelően hozzunk létre egy olyan objektumot, amely az Angularos EventEmitter osztály objektuma lesz. <br>
          serverCreated = new EventEmitter&lt&gt.</li>
        <li>A &lt&gt közé illesszük a szülő komponensben az eventhez tartozó metódusnál megadott objektumot. <br>
          &lt{serverName: string, serverContent: string}&gt</li>
        <li>A gyerek komponensben olyan metódust adjunk meg, aminél az EventEmitter emit metódusát alkalmazzuk. <br>
          this.serverCreated.emit({serverName: this.newServerName, serverContent: this.newServerContent}) <br>
          Ahogy látható, a ()-ben az az objektum van, amit a 4. pontban is megadtunk.</li>
        <li>Tegyünk @Output()-t az event neve elé, ugyanis a gyerek komponensből küldünk adatokat a szülő komponens felé
          @Output() serverCreated</li>
      </ol>
      <p>Összefoglalva: Hozzunk létre custom eventeket a szülő komponensben, amit EventEmitterrel definiálunk a gyerek komponensben. Ez lesz az Output, mivel az adatok a gyerek komponenstől kifelé áramlanak. Ha pedig adatot szeretnénk továbbítani a szülőtől a gyerek felé, akkor hozzunk létre custom propertyt, és ezt a gyerek komponensben Inputtal definiáljuk!</p>
      <h3>View Encapsulation</h3>
      <p>Az Angular a különböző komponensekben található elemeket különböző, az adott komponensre jellemző osztályokkal látja el, amelynek segítségével tényleg csak az adott komponens stílusát tudjuk változtatni. Amennyiben ezen változtatni szeretnénk, úgy a @Component-en belül meg kell adni azt, hogy <br>
        encapsulation: ViewEncapsulation.{valami}. <br>
        A {valami} lehet:</p>
      <ul style="list-style: lower-alpha;">
        <li>Emulated - ez a default</li>
        <li>None - ekkor kikapcsoljuk a View Encapsulationt az adott komponensre. Ha ezen komponensen belül adunk meg stílust a CSS fájlban, az globálisan minden komponensre használódni fog.</li>
        <li>ShadowDom</li>
      </ul>
      <p>Dokumentáció: <a href="https://angular.io/guide/view-encapsulation">[Angular]</a></p>
      <h3>Local Reference</h3>
      <p>Local Reference létrehozása: tetszőleges html tagen belül #{név}. <br>
        <img src="../img/angular/Kép23.jpg" alt=""> <br> 
        A local referencet bárhol lehet használni, de csak a templaten belül, a TS fájlokban nem! <br>
        A local reference típusa templaten belül Element!</p>
      <p>Ahhoz, hogy tudjuk használni TS fájlban, úgy a local referencet meg kell adni a komponensosztályban, elé kell írni a @ViewChild() dekorátort.
        @ViewChild({loc. ref.}, {static: true}) {loc. ref.} <br>
        <img src="../img/angular/Kép24.jpg" alt=""> <br>
        Ennek a típusa ElementRef lesz! <strong>Ezt és a ViewChildot is importálni kell a core-ból!</strong></p>
      <p>Input elemek értékeit a value metódussal tudjuk felhasználni. <br>
        <img src="../img/angular/Kép25.jpg" alt=""></p>
      <p>Ha valami contentet teszünk a komponenshez tartozó tagek közé, akkor azt tapasztaljuk, hogy a tárolt értékek elvesznek. Hibát nem kapunk, viszont az Angular nem törődik azzal, hogy ilyen tagek között megőrizze a változók értékeit. Ahhoz, hogy ez ne így legyen, úgy a komponenshez tartozó html fájlban meg kell adni az &ltng-content&gt&lt/ng-content&gt tag párokat. Ez is directive, viszont a többivel ellentétben ezt tagként adjuk meg.</p>
    </div>

    <div id="course-project-komponensek">
      <h2>Komponensek - Course Project rövid összefoglaló</h2>
      <ol start="8">
        <li>Ha több szinttel lejjebb található gyerektől szeretnénk adatot begyűjteni, akkor többször kell használni az EventEmittert, hogy feljusson az adat ahhoz a szülő komponenshez, ahová el szeretnénk juttatni az adatot.</li>
        <li>Ha valami speciális szöveget szeretnénk megjeleníttetni, például kezdetekben, akkor használjuk az ng-template taget.</li>
      </ol>
    </div>

    <div id="directives-deep-dive">
      <h2>Directives deep dive</h2>
      <p>Ha dinamikusan szeretnénk szerkezetet vagy attribútumot változtatni, akkor használjuk!</p>
      <p>Attribute directives - úgy viselkednek, mint a HTML attribútumok. Csak azokat a HTML elemeket módosítják, amihez hozzáadjuk őket. Ilyen az ngClass és az ngStyle.</p>
      <p>Structural directives - úgy néz ki, mint egy HTML attribútum, de van egy csillag a nevük előtt. Ezek a directivek a DOM-ot változtatják. Ilyen az ngIf és az ngFor.</p>
      <p>Saját directive létrehozása:</p>
      <ol>
        <li>Külön mappa egy sokatmondó névvel</li>
        <li>{név}.directive.ts létrehozása a mappán belül <br>
        <img src="../img/angular/Kép26.jpg" alt=""></li>
        <li>Adjuk meg a @Directive dekorátort, amit importálni kell a @angular/core-ból!</li>
        <li>A dekorátoron belül a következőket kell megadni:</li>
        <ul style="list-style-type: lower-alpha;">
          <li>selector: milyen néven tudjuk elérni a directivet.</li>
        </ul>
        <img src="../img/angular/Kép27.jpg" alt="">
        <li>Létrehozzuk az osztályt és exportáljuk (export class {név} implements OnInit)</li>
        <ul style="list-style: lower-alpha;">
          <li>Az osztályon belülre kell egy constructor, zárójelen belülre azt kell írni, hogy private elementRef: ElementRef (amit importálni kell szintén)</li>
          <li>Kell egy ngOnInit(), amibe azt kell írni, hogy this.elementRef.nativeElement.style és ezután hogy melyik propertyt szeretnénk változtatni és ennek milyen értéket szeretnénk adni.</li>
        </ul>
        <li>Az app.module.ts-ben a declarations-nél meg kell adni a directiveünket (és importáljuk is!), hisz alapesetben az Angular nem szkenneli be az összef fájlt.</li>
        <li>Ezután az általunk megadott selectort adjuk meg a HTML tagnek attribútumként.</li>
      </ol>
      <p>Vagy létrehozhatjuk terminálon keresztül: ng g d {directive-név}. Ekkor az 1-4. illetve a 6. kimarad, viszont tegyük külön mappába a directivet, amit alapból nem tesz meg az Angular terminálos telepítés során. Ebben az esetben az importálás is változik (lásd 6. pont).</p>
      <p>Ha kicsit fejlettebben szeretnénk megvalósítani, akkor a constructorhoz adjunk hozzá egy private renderert, aminek a típusa Renderer2 lesz (importálni!). Az ngOnInit-en belül meg kell adni azt, hogy this.renderer.setStyle(), és a zárójelen belül három paramétert:</p>
      <ul style="list-style: lower-alpha;">
        <li>az elemet, aminek a stílusát módosítanánk (leggyakrabban this.elRef.nativeElement)</li>
        <li>a CSS propertyt (itt nincs camelCase)</li>
        <li>a property új értékét</li>
      </ul>
      <p>@HostListener dekorátorral különböző eventeket tudunk rendelni a directivehez. <br>
      <img src="../img/angular/Kép28.jpg" alt=""></p>
      <p>Nem csak a rendererrel lehet változtatni a stíluson. A másik módszerhez szükségünk van a @HostBinding dekorátorra <br>
        @HostBinding({amit változtatni akarunk}) {név} <br>
        Pl.: @HostBinding('.style.backgroundColor') backgroundColor <br>
        Ezek után elég azt megadni a HostListenerben, hogy this.backgroundColor = {valami}. <br>
        <img src="../img/angular/Kép29.jpg" alt=""></p>
      <h3>NgSwitch</h3>
      <p>Egy directive, amit switch-case esetén használunk.</p>
      <p>A különböző értékekhez *ngSwitchCaset kell megadni, a default értékhez pedig *ngSwitchDefault-ot. <br>
        <img src="../img/angular/Kép30.jpg" alt=""></p>
    </div>

    <div id="services">
      <h2>Services & Dependency Injection</h2>
      <p>Akkor használjuk, ha bizonyos osztályokat újra fel szeretnénk használni!</p>
      <p>Dokumentáció: <a href="https://angular.io/guide/architecture-services">[Angular]</a></p>
      <p>Service létrehozása általánosan:</p>
      <ol>
        <li>Létrehozunk egy valami.service.ts fájlt.</li>
        <li>Ebben a fájlban létrehozunk egy osztályt, amit exportálunk. Ebben vannak változók és metódusok, amiket később újra lehet használni.</li>
        <li>Ahol szeretnénk használni a servicet, ott kell providolni (lásd lejjebb a <a href="#hierch">hiearchical injectionnél</a>) <br>
          <img src="../img/angular/Kép31.jpg" alt=""></li>
        <li>Komponensbe úgy tudjuk injektálni a szervert, hogy létrehozunk egy constructort, aminek a paramétere egy private, a service nevével megegyező típusú lesz (amit importálni kell). <br>
          <img src="../img/angular/Kép32.jpg" alt=""></li>
        <li>Ha az adatokat be szeretnénk olvastatni, mert például tömbben tároljuk azokat, akkor szükség van az OnInitre. (... implements OnInit +NgOnInit())</li>
        <li>Ha servicet szeretnénk másikba injektálni, akkor a metódus ugyanaz, mint a 4. pontban, viszont mindkét servicenél kell az @Injectable() dekorátor, amit importálni kell. <br>
          <img src="../img/angular/Kép33.jpg" alt=""></li>
      </ol>
      <p>Alább egy példa:</p>
      <p>Logging service létrehozása - egy eszköz, amivel konzolra íratást tudunk megvalósítani.</p>
      <ol>
        <li>Az app mappán belül logging.service.ts.</li>
        <li>Létrehozni és exportálni egy osztályt, a név mindegy (de a legjobb a LoggingService)</li>
        <li>Osztályon belül egy metódus létrehozása, ami a konzolon megjelenítendő szöveget tartalmazza.</li>
        <li>Azon a komponensen belül, ahol szeretnénk használni a LoggingService-t:</li>
        <ul style="list-style: lower-alpha;">
          <li>A @Componenthez hozzá kell adni azt, hogy providers: [LoggingService] <br>
            <img src="../img/angular/Kép34.jpg" alt=""></li>
          <li>Létre kell hozni egy constructort: constructor(private loggingService: LoggingService) {}</li>
          <li>És a megfelelő helyen meg kell hívni a konzolra kiíratást: this.loggingService.logStatusChange(accountStatus);</li>
        </ul>
      </ol>
      <p>A Data servicet hasonlóan hozzuk létre. Ott az osztályban a kezdeti adatokat és az osztályhoz tartozó metódusokat adjuk meg.</p>
      <h3 id="hierch">Hierarchical injection</h3>
      <ol>
        <li>AppModule - ha az appModuleban providoljuk a servicet, akkor az egész appon belül elérhető lesz a service ugyanazon változata</li>
        <li>AppComponent - ha az appComponentben providoljuk a servicet, akkor az összes komponensben elérhető lesz a service ugyanazon változata</li>
        <li>Bármely más komponens - ha bármely más komponensben providoljuk a servicet, akkor az adott komponensben és a gyerek komponenseiben lesz elérhető a service ugyanazon változata</li>
      </ol>
      <p>Tehát: <br>
        A logging servicet csak a gyerek komponensekben providoltuk, így ezek egymástól függetlenül mennek -> nem lesz bug <br>
        A data servicet viszont az AppComponentben providoltuk, éppen ezért, ha a két másik komponensben is providoljuk, akkor hibát kapunk -> tehát elég csak az AppComponentben providolni a servicet, mert ugyanazt a változatát használjuk a servicenek a gyerek komponensekben is.</p>
      <p>Ha több servicet szeretnénk egymásba építeni, akkor minden servicenél meg kell adni az @Injectable() dekorátort.</p>
    </div>

    <div id="routing">
      <h2>Routing</h2>
      <p>A weboldalunkat különböző útvonalakkal tudjuk bővíteni, amik más-más komponenst jelenítenek meg anélkül, hogy az adott oldalt frissítené/újratöltené.</p>
      <p>Routing létrehozása:</p>
      <ol>
        <li>app.module.ts-ben egy konstanst létre kell hozni appRoutes néven, aminek típusa Routes, amit importálni kell az @angular/routerről.</li>
        <li>Ez az appRoutes egy tömb és objektumokat tartalmaz, amiknek 2 paramétert kell megadni:</li>
        <ul style="list-style: lower-alpha;">
          <li>path: az útvonal, amivel elérjük az adott részt (/ nélkül)</li>
          <li>component: amelyik komponensnek meg kell jelennie, ha azt az útvonalat adjuk meg</li>
        </ul>
        <li>Importsnál megadni: RouterModule.forRoot(appRoutes) -> RouterModule-t importálni</li>
        <li>router-outlet directive megadása a komponens html fájlában oda, ahol szeretnénk, hogy a komponensek betöltődjenek.</li>
        <li>Az anchor tagek href-je automatikusan újrafrissíti az oldalt, ami az adatok elvesztéséhez vezet. Ennek elkerülésére használjuk az Angular routerLink attribútumát, ami ugyanúgy működik, mint a href, csak nem tölti be újra az oldalt.</li>
      </ol>
      <p>Relative path: amikor az útvonalat / nélkül adjuk meg. Ilyenkor az Angular megpróbálja kiegészíteni az útvonalat az általunk megadottakkal. Ami gyakran errorhoz vezethet. <br>
        Absolute path: amikor az útvonalat /-rel adjuk meg. Ilyenkor az alapútvonalat egészíti ki az általunk megadottakkal.</p>
      <p>Ha az útvonalban azt adjuk meg, hogy "../valami", akkor egy szinttel feljebb lépünk.</p>
      <p>Aktív routerLinkhez osztály hozzáadás: routerLinkActive="valami". <br>
        De ezzel vigyázni kell. Mert minden olyan tagre alkalmazza az osztályt, ami részben vagy teljesen szerepel az adott útvonalban. Tehát pl. a homepage mindig megkapja az osztályt, mert a homepage útvonala részben megegyezik bármelyik komponens útvonalával. <br>
        Ahhoz, hogy ezt elkerüljük, meg kell adni még a [routerLinkActiveOptions] property bindingot, amelynek értéke egy objektum lesz, amivel például ki tudjuk azt fejezni, hogy a teljes útvonalat vegye csak-e figyelembe az osztály hozzáadásakor, vagy csak a részútvonalat. (Ha exact: true, akkor a teljes útvonalat veszi figyelembe). <br>
        [routerLinkActiveOptions]="{exact: true}"
        </p>
      <p>Ahhoz, hogy egy gombra rányomva egy adott "oldalra" jussunk, létre kell hozni egy gombot, amihez hozzárendelünk egy eventet. A komponensnél a constructorba beinjektáljuk a routert (private router: Router), majd az eventhez tartozó metódushoz a következőt adjuk meg:  this.router.navigate(['/servers']); (ahol a /servers egy absolute path és természetesen a servers módosítható). <br>
        Ha relative pathot adunk meg, akkor érdemes tudni: maga a navigate nem tudja, hogy épp hol állunk a weboldalon, így ha relative pathot adunk meg, akkor automatikusan a rootot egészíti ki az általunk megadott útvonallal. Ezt elkerülve meg kell adni egy JS objektumot, aminek az egyik paramétere relativeTo és aminek értéke this.route. Ehhez injektáljunk egy routeot, aminek típusa ActivatedRoute lesz (ami tudja azt, hogy épp hol állunk a weboldalon belül) és amit szintén importálni kell a @angular/routerből.</p>
      <p>Útvonalakat dinamikusan úgyis tudunk megadni, ha az útvonalakat bizonyos paraméterekkel bővítünk. Ehhez :-ot kell használni, például: path: 'users/:id', component: UserComponent. <br>
        De hogyan tudjuk a megfelelő komponenst elérni?</p>
      <ol>
        <li>A megfelelő komponens constructorába injektáljuk be a route-ot, ami ActivatedRoute típusú.</li>
        <li>this.route.snapshot.params['id'] segítségével tudunk paramétert kinyerni az URL-ből. A [] közé olyan értéket adjunk, amilyen nevet adtunk a paraméternek az útvonalmegadásánál az app.module.ts-ben!</li>
      </ol>
      <p>Arra kell figyelni, hogyha mondjuk updateljük az URL-t routerLinkkel, viszont nem hagyjuk el azt a komponenst, akkor az adatok nem fognak frissülni, ugyanis ezt az Angular érzékeli és nem érti, miért kell frissítenie az adatokat, ha nem hagyjuk el az adott komponenst.</p>
      <p>Az adatok frissítéséhez ezt kell megadni az ngOnInit()-en belül:</p>
      <p>(Természetesen a megfelelő paraméterek megadásával).</p>
      <p>Mivel a subscribe az app bezárása után is megmarad a memóriában, így az OnDestroy segítségével "el kell pusztítani", miután bezártuk az appot.</p>
      <p>Ezt kell megadni a komponens fájlban akkor is, amikor dinamikusan szeretnénk url-t csatolni az anchor taghez!</p>
      <p>Anchor tagen belül: <br>
        [queryParams]={} - ? az URL-ben <br>
        fragment="" - # az URL-ben <br>
        A navigate metóduson belül pedig: this.router.navigate(['/servers', id, 'edit'], {queryParams: {allowEdit: '1'}, fragment: "loading"});</p>
      <p>Ha azt szeretnénk, hogy több komponens is megjelenjen az oldalon, akkor beágyazott linkeket kell létrehozni az app.module.ts-ben, amit úgy tehetünk meg, hogy ahhoz az útvonalhoz (ami több komponens része) tartozó JS objektumot kibővítjük egy children propertyvel, ide tömbösítve megadjuk az abból kiinduló útvonalakat. Viszont kezdetben a router-outletet csak az app html-jében adtuk meg, ami csak az app utáni követező szinten lévő linkeket ismeri fel. Tehát, hogy ne kapjunk errort, az összes olyan komponens HTML-jéhez hozzá kell adni a router-outletet, amihez hozzáadtunk gyerekútvonalakat.</p>
      <p>Ahhoz hogy a query parametereket megtartsuk, hozzá kell adni a navigate metódus JS objektumához a queryParamsHandling propertyt. Két értéket lehet neki adni: a merget és a preservet. Ha meg szeretnénk tartani a query paramétereket, a preserve értéket kell megadni. <br>
        this.router.navigate(['edit'], {relativeTo: this.route, queryParamsHandling: 'preserve'});</p>
      <p>Wildcard route: '**'. Célszerű csinálni egy page not found komponenst, arra írni egy útvonalat és a wildcard routeot átirányítani arra a komponensre és útvonalra, ami a hibás oldalért felel.</p>
      <p>Célszerű a routingot új moduleba kimenteni (pl. app-routing.module.ts), hogy könnyebben olvashatóbbak legyenek a kódok. A module ugyanúgy néz ki, mint a gyári app.module.ts, arra kell figyelni, hogy az NgModuleon belül ezeket adjuk meg:</p>
      <p>A komponenseket nem kell importálni, azokat már megtettük a fő moduleban. <br>
        Az app.module.ts-ben az imports-on belül adjuk meg a moduleunk nevét, ahogy az export classnál elneveztük.</p>
      <h3>Guarding</h3>
      <p>CanActivate dokumentáció: <a href="https://angular.io/api/router/CanActivate">[Angular]</a></p>
      <p>Beállíthatjuk, hogy a weboldal mely komponenseit lehet elérni és melyiket nem, illetve ehhez tudunk feltételeket szabni. Ehhez két service kell: AuthService és AuthGuard. Az AuthGuardhoz implementálni kell a CanActivate interfacet. Majd ezt kell megadni:</p>
      <p>Ezt a guardot hozzá kell adni az útvonalhoz tartozó JS objektumhoz: canActivate: [AuthGuard], illetve mindkét servicet hozzá kell adni az app.module.ts-ben. <br>
        Ha az útvonal gyerekét szeretnénk védeni, akkor a canActivateChild propertyt kell megadni. <br>
        Statikus szöveg útvonalhoz megadása: data: {message: ""}</p>
    </div>

    <div id="course-project-routing">
      <h2>Routing összefoglaló</h2>
    </div>
  </div>
    
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>
  <script src="index.js"></script>

</body>
</html>