<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <link rel="stylesheet" href="../style/nyelvek.css">
    <title>MySQL</title>
</head>
<body>
  <nav class="navbar navbar-expand-xl navbar-dark navbar-bg">
    <div class="container-fluid col-lg-8 col-md-10 col-sm-12">
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarTogglerDemo02" aria-controls="navbarTogglerDemo02" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarTogglerDemo02">
        <!--Az első négy gomb bal oldalra zárva - ezek külön ul-ben vannak-->
        <ul class="navbar-nav me-auto mb-2 mb-lg-0">
          <li class="nav-item dropdown"><a class="nav-link" href="html.html">HTML</a></li>
          <li class="nav-item dropdown"><a class="nav-link" href="css.html">CSS</a></li>
          <li class="nav-item dropdown"><a class="nav-link" href="js.html">JS</a></li>
          <li class="nav-item dropdown"><a class="nav-link" href="ts.html">TS</a></li>
          <li class="nav-item dropdown"><a class="nav-link active disabled" href="mysql.html">MySQL</a></li>
          <li class="nav-item dropdown"><a class="nav-link" href="nodejs.html">NodeJS</a></li>
          <li class="nav-item dropdown"><a class="nav-link" href="angular.html">Angular</a></li>
        </ul>
        <!--Az érdekességek lenyíló lista jobb oldalra zárva, ez is külön ul-ben van-->
        <ul class="navbar-nav ms-auto mb-2 mb-lg-0">
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown04" role="button" data-bs-toggle="dropdown" aria-expanded="false">
              Érdekesség
            </a>
            <ul class="dropdown-menu dropdown-bg" aria-labelledby="navbarDropdown04">
              
            </ul>
          </li>
        </ul>
      </div>
    </div>
  </nav>

  <div id="content-container" class="container-fluid col-lg-8 col-md-10 col-sm-12">
    <div>
        <h1>MySQL</h1>
        <h2>Az oldal tartalma</h2>
        <ol>
            <li><a href="#kulcsszavak">Kulcsszavak</a></li>
            <li><a href="#kezdetek">A kezdetek</a></li>
            <li><a href="#adatbazisok">Adatbázisok, SQL, MySQL</a></li>
            <li><a href="#tablazatok">Táblázatok</a></li>
            <li><a href="#tablazat-keszitese">Táblázat készítése és alapkulcsszavak</a></li>
            <li><a href="#null">NOT vs NOT NULL, default érték</a></li>
            <li><a href="#primary-keys">Kulcsok - Primary Keys</a></li>
            <li><a href="#crud">CRUD</a></li>
            <li><a href="#sql-programok">SQL programok írása</a></li>
            <li><a href="#string-functions">MySQL string függvények</a></li>
            <li><a href="#finomitas">A lekérdezett adatok finomítása</a></li>
            <li><a href="#aggregate">Összegző (aggregate) függvények és adatok csoportosítása</a></li>
            <li><a href="#adattipusok">Adattípusok áttekintése</a></li>
            <li><a href="#date-maths">Dátumok formázása és a "dátum matek"</a></li>
            <li><a href="#logical-operators">Logikai operátorok</a></li>
            <li><a href="#constraint">Megszorítások (Constraintek) és táblák módosítása</a></li>
            <li><a href="#kapcsolatok">Kapcsolatok</a></li>
            <li><a href="#joins">JOIN-ok, 1:n kapcsolat</a></li>
            <li><a href="#nn">n:n kapcsolat</a></li>
            <li><a href="#views">Táblák létrehozása (views)</a></li>
            <li><a href="#modes">Különböző módok (modes)</a></li>
            <li><a href="#windowfunctions">Ablakfüggvények</a></li>
        </ol>
    </div>

    <div id="kulcsszavak">
      <h2>Kulcsszavak</h2>
      <h3>Létrehozással kapcsolatos kulcsszavak</h3>
      <table>
        <tr>
          <th>Kulcsszó</th>
          <th>Szerep</th>
          <th>Dokumentáció</th>
        </tr>
        <tr>
          <td>CREATE DATABASE {név}</td>
          <td>Adatbázis létrehozása.</td>
          <td><a href="#tablazat-keszitese">[html]</a></td>
        </tr>
        <tr>
          <td>SHOW DATABASES</td>
          <td>Az összes adatbázis lekérdezése, ami a szerveren található.</td>
          <td><a href="#tablazat-keszitese">[html]</a></td>
        </tr>
        <tr>
          <td>SELECT DATABASE()</td>
          <td>Aktív adatbázisok lekérdezése.</td>
          <td><a href="#tablazat-keszitese">[html]</a></td>
        </tr>
        <tr>
          <td>DROP DATABASE {név}</td>
          <td>Adatbázis törlése. A törlés végleges.</td>
          <td><a href="#tablazat-keszitese">[html]</a></td>
        </tr>
        <tr>
          <td>USE {név}</td>
          <td>A USE után megadott adatbázisba lépünk, ez lesz az aktív adatbázisunk.</td>
          <td><a href="#tablazat-keszitese">[html]</a></td>
        </tr>
        <tr>
          <td>SHOW TABLES</td>
          <td>Megmutatja az aktuális adatbázisban található összes táblát.</td>
          <td><a href="#tablazat-keszitese">[html]</a></td>
        </tr>
        <tr>
          <td>DESC {név} vagy <br> SHOW COLUMNS FROM {név}</td>
          <td>Egy általunk megadott tábláról kapunk információkat.</td>
          <td><a href="#tablazat-keszitese">[html]</a></td>
        </tr>
        <tr>
          <td>DROP TABLE</td>
          <td>Tábla törlése. A törlés végleges.</td>
          <td><a href="#tablazat-keszitese">[html]</a></td>
        </tr>
        <tr>
          <td>CREATE TABLE</td>
          <td>Tábla létrehozása.</td>
          <td><a href="#tablazat-keszitese">[html]</a></td>
        </tr>
        <tr>
          <td>NULL</td>
          <td>Default beállítás. Az értékét nem ismerjük, nincs meghatározott értéke és nem ekvivalens a nullával. Amennyiben ha rekordot adunk a táblához, és az egyik oszlopához nem rendelünk értéket, akkor automatikusan NULL érték kerül.</td>
          <td><a href="#null">[html]</a></td>
        </tr>
        <tr>
          <td>NOT NULL</td>
          <td>A NOT NULL megadásával elkerülhetjük a NULL értékeket. Ha valamihez nem rendelünk értéket, akkor nem NULL érték jelenik meg, hanem az adott adattípusban a 0-val ekvivalens érték. Például VARCHAR-nál üres string, INT-nél 0.</td>
          <td><a href="#null">[html]</a></td>
        </tr>
        <tr>
          <td>DEFAULT</td>
          <td>Amennyiben a tábla készítésénél az egyik mezőhöz rendelünk default értéket, akkor a rekord megadásakor, ha valamihez nem írunk adatot, automatikusan a default érték kerül megadásra.</td>
          <td><a href="#null">[html]</a></td>
        </tr>
        <tr>
          <td>PRIMARY KEY</td>
          <td>Egy kulcs, amely segítségünkre van abban, hogy egy bizonyos adat csak egyszer szerepeljen egy adott mezőben. Legtöbbször ID-khez rendeljük, mert azok, amik leginkább egyediek. A PRIMARY KEY-t rendelhetjük egy adott mezőhöz vagy a tábla létrehozásakor a legvégén is megadhatjuk, zárójelben, hogy melyik mezőt szeretnénk primary key-nek tekinteni. Csak egy lehet belőle egy táblában.</td>
          <td><a href="#primary-keys">[html]</a></td>
        </tr>
        <tr>
          <td>AUTO_INCREMENT</td>
          <td>Bizonyos mező értékei minden újabb rekord létrehozásával emelkedik. Ezt is célszerű akkor használni, ha van ID mezőnk és célszerű együtt használni a primary key-el.</td>
          <td><a href="#primary-keys">[html]</a></td>
        </tr>
        <tr>
          <td>UNIQUE</td>
          <td>Garantálja, hogy az adott mezőben minden érték csak egyszer forduljon elő. Hasonlít a Primary Keyhez, tulajdonképpen a primary key is rendelkezik a unique megszorítással. A különbség a kettő között az, hogy míg Primary Keyből csak 1 lehet táblánként, addig Uniqueból lehet több.</td>
          <td><a href="#constraint">[html]</a><a href="https://www.w3schools.com/mysql/mysql_unique.asp">[w3]</a></td>
        </tr>
        <tr>
          <td>CHECK</td>
          <td>Egy feltétel, amellyel kontrollálni tudjuk, milyen rekordok kerüljenek be a táblába.</td>
          <td><a href="#constraint">[html]</a></td>
        </tr>
        <tr>
          <td>CONSTRAINT</td>
          <td>A CONSTRAINT kulccszó után tudjuk megadni a megszorításunkat, amelynek nevet is tudunk adni, így ha nem teljesül a feltétel, akkor a hibaüzenetben visszakapjuk, hogy miért nem teljesül. A CONSTRAINT a tábla létrehozásának végén szerepel.</td>
          <td><a href="#constraint">[html]</a></td>
        </tr>
        <tr>
          <td>IF EXISTS</td>
          <td>Annak ellenőrzésére szolgál, hogy egy adatbázis vagy egy tábla létezik-e. Amennyiben nem, úgy azt létrehozza, amennyiben igen, úgy nem történik semmi. Fontos szerepe van, ugyanis amennyiben kihagyjuk, és egy olyan adatbázist vagy táblát szeretnénk létrehozni, ami már létezik, akkor hibaüzenetet kapunk.</td>
          <td></td>
        </tr>
      </table>

      <h3>Táblák módosítása</h3>
      <table>
        <tr>
          <th>Kulcsszó</th>
          <th>Szerep</th>
          <th>Dokumentáció</th>
        </tr>
        <tr>
          <td>ALTER TABLE</td>
          <td>Táblákat az ALTER TABLE kulcsszó segítségével tudunk módosítani. Többféle módosítás lehetséges. Például: Oszlop hozzáadása, illetve elhagyása, átnevezés, oszlopok módosítása illetve megszorítások kötése.</td>
          <td><a href="#constraint">[html]</a></td>
        </tr>
        <tr>
          <td>ADD COLUMN</td>
          <td>Oszlop hozzáadása a már meglévő táblához.</td>
          <td><a href="#constraint">[html]</a></td>
        </tr>
        <tr>
          <td>DROP COLUMN</td>
          <td>Oszlop elhagyása a már meglévő táblából.</td>
          <td><a href="#constraint">[html]</a></td>
        </tr>
        <tr>
          <td>RENAME TABLE ... TO ...</td>
          <td>Tábla átnevezése.</td>
          <td><a href="#constraint">[html]</a></td>
        </tr>
        <tr>
          <td>ALTER TABLE ... RENAME TO ...</td>
          <td>Tábla átnevezése.</td>
          <td><a href="#constraint">[html]</a></td>
        </tr>
        <tr>
          <td>RENAME COLUMN ... TO ...</td>
          <td>Oszlop átnevezése.</td>
          <td><a href="#constraint">[html]</a></td>
        </tr>
        <tr>
          <td>MODIFY</td>
          <td>Oszlop típusának megváltoztatása.</td>
          <td><a href="#constraint">[html]</a></td>
        </tr>
        <tr>
          <td>CHANGE</td>
          <td>Oszlop nevének és típusának megváltozatása.</td>
          <td><a href="#constraint">[html]</a></td>
        </tr>
        <tr>
          <td>ADD CONSTRAINT</td>
          <td>Megszorítás hozzáadása.</td>
          <td><a href="#constraint">[html]</a></td>
        </tr>
        <tr>
          <td>DROP CONSTRAINT</td>
          <td>Megszorítás törlése.</td>
          <td><a href="#constraint">[html]</a></td>
        </tr>
      </table>

      <h3>CRUD kulcsszavak</h3>
      <table>
        <tr>
          <th>Kulcsszó</th>
          <th>Szerep</th>
          <th>Dokumentáció</th>
        </tr>
        <tr>
          <td>INSERT INTO {table}({columns}) VALUES ({values})</td>
          <td>Adatok hozzáadása a táblához.</td>
          <td><a href="#crud">[html]</a></td>
        </tr>
        <tr>
          <td>SELECT {mezok} FROM {tabla}</td>
          <td>Adatok lekérdezése egy adott táblából. Ha a SELECT után * van, akkor az összes adatot megkapjuk, ha bizonyos mezőnév vagy mezőnevek, akkor az azokhoz a mezőkhöz tartozó adatokat kapjuk vissza.</td>
          <td><a href="#crud">[html]</a></td>
        </tr>
        <tr>
          <td>WHERE {feltetel}</td>
          <td>Csak azokat az adatokat kapjuk vissza, amikre teljesül a feltétel.</td>
          <td><a href="#crud">[html]</a></td>
        </tr>
        <tr>
          <td>UPDATE {table} SET {column}={value} (+ feltétel)</td>
          <td>Tábla bizonyos oszlopában található értékek frissítése, amennyiben az általunk megadott feltétel teljesül. Amennyiben nem adunk meg feltételt, úgy az adott oszlopban található összes érték frissülni fog.</td>
          <td><a href="#crud">[html]</a></td>
        </tr>
        <tr>
          <td>DELETE FROM {table} (+ feltétel)</td>
          <td>Azon rekordok törlése a táblából, amelyekre teljesül a feltétel. Amennyiben nem adunk meg feltételt, úgy az összes rekordot töröljük a táblából, de szemben a DROP TABLE-vel, maga a tábla megmarad, csak üres lesz.</td>
          <td><a href="#crud">[html]</a></td>
        </tr>
      </table>

      <h3>String függvények:</h3>
      <table>
        <tr>
          <th>Kulcsszó</th>
          <th>Szerep</th>
          <th>Dokumentáció</th>
        </tr>
        <tr>
          <td>CONCAT</td>
          <td>Több mező tartalmának összefűzése.</td>
          <td><a href="#string-functions">[html]</a></td>
        </tr>
        <tr>
          <td>CONCAT_WS</td>
          <td>Több mező tartalmának összefűzése a megadott elválasztókarakterrel.</td>
          <td><a href="#string-functions">[html]</a></td>
        </tr>
        <tr>
          <td>SUBSTRING (SUBSTR)</td>
          <td>Mező tartalmának levágása. Kétféleképp tudjuk használni: vagy két paramétert adunk meg neki vagy hármat (amiből az egyik a string, amit le akarunk vágni).</td>
          <td><a href="#string-functions">[html]</a></td>
        </tr>
        <tr>
          <td>REPLACE</td>
          <td>A szöveg egy részeit kicseréljük másra.</td>
          <td><a href="#string-functions">[html]</a></td>
        </tr>
        <tr>
          <td>REVERSE</td>
          <td>A szöveget megfordítjuk.</td>
          <td><a href="#string-functions">[html]</a></td>
        </tr>
        <tr>
          <td>CHAR_LENGTH</td>
          <td>A szöveg hosszát kapjuk vissza.</td>
          <td><a href="#string-functions">[html]</a></td>
        </tr>
        <tr>
          <td>UPPER</td>
          <td>A szöveget nagybetűsítjük.</td>
          <td><a href="#string-functions">[html]</a></td>
        </tr>
        <tr>
          <td>LOWER</td>
          <td>A szöveget kisbetűsítjük.</td>
          <td><a href="#string-functions">[html]</a></td>
        </tr>
      </table>

      <h3>Finomítással kapcsolatos kulcsszavak:</h3>
      <table>
        <tr>
          <th>Kulcsszó</th>
          <th>Szerep</th>
          <th>Dokumentáció</th>
        </tr>
        <tr>
          <td>DISTINCT</td>
          <td>Minden duplikált adatból csak egyet kapunk vissza.</td>
          <td><a href="#finomitas">[html]</a></td>
        </tr>
        <tr>
          <td>ORDER BY</td>
          <td>Az adatokat rendezzük vele sorba. Az ORDER BY az általunk írt lekérdezés végén áll. A kulcsszó után megadhatunk számot vagy mezőnevet, ami alapján szeretnénk, hogy a sorbarendezés megtörténjen. Amennyiben számot adunk meg, úgy aszerint a mező szerint rendezzük, amelyik azon a helyen áll a SELECT után, ahányadik számot megadtuk. Nem muszáj olyan mező szerint rendezni, amit lekérdezünk. Ha a szám vagy a mező után az ASC szót írjuk, akkor növekvő, ha a DESC szót írjuk, akkor csökkenő sorrendbe rendezünk. A default beállítás a növekvő, így az ASC-ot nem is szükséges kiírni.</td>
          <td><a href="#finomitas">[html]</a></td>
        </tr>
        <tr>
          <td>LIMIT</td>
          <td>Leszűkítjük a lekérdezés során kapott adatok számát. Ezt is kétféleképpen tudjuk megadni: vagy egy számot adunk meg és akkor a legelső X találatot kapjuk vissza, vagy két számot (vesszővel elválasztva) és akkor eltolva kapunk vissza X találatot.</td>
          <td><a href="#finomitas">[html]</a></td>
        </tr>
      </table>

      <h3>Csoportosítással kapcsolatos kulcsszavak</h3>
      <table>
        <tr>
          <th>Kulcsszó</th>
          <th>Szerep</th>
          <th>Dokumentáció</th>
        </tr>
        <tr>
          <td>GROUP BY</td>
          <td>Bizonyos mezőben található adatok csoportosítása az értékük alapján.</td>
          <td><a href="#aggregate">[html]</a></td>
        </tr>
        <tr>
          <td>COUNT()</td>
          <td>Adatok megszámolása. Ha a GROUP BY-jal használjuk együtt, akkor megszámoljuk, hogy egy csoporthoz mennyi adat tartozik.</td>
          <td><a href="#aggregate">[html]</a></td>
        </tr>
        <tr>
          <td>MIN()</td>
          <td>A minimális értéket határozhatjuk meg vele. Ha a minimális érték mellé szeretnénk valamit kiíratni, akkor subqueryt kell használni, máskülönben pontatlan eredményt kapunk. GROUP BY-jal használva a csoport egy minimális értékét tudjuk meghatározni vele (például ha könyvek vannak, akkor a különböző írók legkorábbi könyvét).</td>
          <td><a href="#aggregate">[html]</a></td>
        </tr>
        <tr>
          <td>MAX()</td>
          <td>A maximális értéket határozhatjuk meg vele. Ha a maximális érték mellé szeretnénk valamit kiíratni, akkor subqueryt kell használni, máskülönben pontatlan eredményt kapunk. GROUP BY-jal használva a csoport egy maximális értékét tudjuk meghatározni vele (például ha könyvek vannak, akkor a különböző írók legkésőbbi könyvét).</td>
          <td><a href="#aggregate">[html]</a></td>
        </tr>
        <tr>
          <td>SUBQUERIES</td>
          <td>Amikor egy lekérdezésen belül szerepel egy másik lekérdezés, általában a feltételben. Minden esetben a belső lekérdezés hajtódik végre, az eredmény pedig egy tábla lesz még akkor is, ha csak 1 értéket kapunk meg. Viszont nem mindig ez a legjobb módszer, hisz ha egy nagy adathalmazzal rendelkező táblára több lekérdezést hajtunk végre, az rengeteg idő és memória. Így csak akkor használjuk, ha nincs más megoldás a feladat elvégzésére.</td>
          <td><a href="#aggregate">[html]</a></td>
        </tr>
        <tr>
          <td>SUM()</td>
          <td>Bizonyos mezőkben található számokat tudunk vele összegezni.</td>
          <td><a href="#aggregate">[html]</a></td>
        </tr>
        <tr>
          <td>AVG()</td>
          <td>Bizonyos mezőkben található számokat tudunk vele átlagolni.</td>
          <td><a href="#aggregate">[html]</a></td>
        </tr>
        <tr>
          <td>ROUND(x,y)</td>
          <td>Számok kerekítésére szolgál.</td>
          <td><a href="#aggregate">[html]</a><a href="https://www.w3schools.com/sql/func_mysql_round.asp">[w3]</a></td>
        </tr>
      </table>

      <h3>Adattípusok</h3>
      <table>
        <tr>
          <th>Kulcsszó</th>
          <th>Szerep</th>
          <th>Dokumentáció</th>
        </tr>
        <tr>
          <td>CHAR(x)</td>
          <td>Karaktertípus, fix memóriafelhasználással. A karakterek hosszának 0 és 255 közötti értéket tudunk megadni.</td>
          <td><a href="#adattipusok">[html]</a><a href="https://dev.mysql.com/doc/refman/8.0/en/char.html">[mysql]</a></td>
        </tr>
        <tr>
          <td>VARCHAR(x)</td>
          <td>Karaktertípus, dinamikusan változó memóriafelhasználással. A karakterek hosszának 0 és 255 közötti értéket tudunk megadni.</td>
          <td><a href="#adattipusok">[html]</a><a href="https://dev.mysql.com/doc/refman/8.0/en/char.html">[mysql]</a></td>
        </tr>
        <tr>
          <td>INT</td>
          <td>Egész számok tárolására használjuk.</td>
          <td><a href="#adattipusok">[html]</a></td>
        </tr>
        <tr>
          <td>DECIMAL(x,y)</td>
          <td>Tizedestörteket tudunk megadni vele. Két paramétert kell megadni: az egyikkel azt tudjuk megadni, hogy összesen hány számjegyből fog állni a szám, a másodikkal, hogy a tizedesvessző után hány számjegy fog állni. Minden esetben az x nagyobb, mint az y. Ha túl sok számjegyből álló számot adunk meg, akkor a lehető legnagyobb szám fog a táblába kerülni.</td>
          <td><a href="#adattipusok">[html]</a></td>
        </tr>
        <tr>
          <td>FLOAT</td>
          <td>Tizedestörteket tudunk megadni vele, 7 számjegyig pontos. Kisebb a memóriaigénye, mint a DOUBLE-nek, viszont kevésbé pontos.</td>
          <td><a href="#adattipusok">[html]</a></td>
        </tr>
        <tr>
          <td>DOUBLE</td>
          <td>Tizedestörteket tudunk megadni vele, 15 számjegyig pontos. Nagyobb a memóriaigénye, mint a FLOAT-nak, viszont pontosabb.</td>
          <td><a href="#adattipusok">[html]</a></td>
        </tr>
        <tr>
          <td>DATE</td>
          <td>Csak dátumot tároló adattípus. Formátuma: 'YYYY-MM-DD'</td>
          <td><a href="#adattipusok">[html]</a></td>
        </tr>
        <tr>
          <td>TIME</td>
          <td>Csak időt tároló adattípus. Formátuma: 'HH:MM:SS'.</td>
          <td><a href="#adattipusok">[html]</a></td>
        </tr>
        <tr>
          <td>DATETIME</td>
          <td>Dátumot és időt tároló adattípus. Formátuma: 'YYYY-MM-DD HH:MM:SS'. Nagyobb a memóriaigénye, mint a TIMESTAMP-nek, viszont nagyobb dátumtartományt képes felismerni és tárolni.</td>
          <td><a href="#adattipusok">[html]</a><a href="https://dev.mysql.com/doc/refman/8.0/en/datetime.html">[mysql]</a></td>
        </tr>
        <tr>
          <td>TIMESTAMP</td>
          <td>Dátumot és időt tároló adattípus. Formátuma: 'YYYY-MM-DD HH:MM:SS'. Kisebb a memóriaigénye, mint a DATETIME-nak, viszont kisebb dátumtartományt képes felismerni és tárolni. Célszerű akkor használni, amikor olyan dátumot tárolunk, ami a közeljövőben volt vagy lesz.</td>
          <td><a href="#adattipusok">[html]</a><a href="https://dev.mysql.com/doc/refman/8.0/en/datetime.html">[mysql]</a></td>
        </tr>
      </table>

      <h3>Adattípusokhoz kapcsolódó kulcsszavak</h3>
      <table>
        <tr>
          <th>Kulcsszó</th>
          <th>Szerep</th>
          <th>Dokumentáció</th>
        </tr>
        <tr>
          <td>CURDATE()</td>
          <td>A jelenlegi dátumot adja vissza. Le tudjuk kérdezni a SELECT-tel.</td>
          <td><a href="#adattipusok">[html]</a></td>
        </tr>
        <tr>
          <td>CURTIME()</td>
          <td>A pontos időt adja vissza. Le tudjuk kérdezni a SELECT-tel.</td>
          <td><a href="#adattipusok">[html]</a></td>
        </tr>
        <tr>
          <td>NOW()</td>
          <td>A jelenlegi dátumot adja vissza a pontos idővel. Le tudjuk kérdezni a SELECT-tel.</td>
          <td><a href="#adattipusok">[html]</a></td>
        </tr>
        <tr>
          <td>DAY()</td>
          <td>A dátumban szereplő nap.</td>
          <td><a href="#date-maths">[html]</a></td>
        </tr>
        <tr>
          <td>DAYNAME()</td>
          <td>Az adott nap neve.</td>
          <td><a href="#date-maths">[html]</a></td>
        </tr>
        <tr>
          <td>DAYOFWEEK()</td>
          <td>Az adott nap hányadik a héten. Vasárnap az 1.!</td>
          <td><a href="#date-maths">[html]</a></td>
        </tr>
        <tr>
          <td>DAYOFYEAR()</td>
          <td>Az adott nap hányadik az évben.</td>
          <td><a href="#date-maths">[html]</a></td>
        </tr>
        <tr>
          <td>MONTH()</td>
          <td>A hónap sorszámát adja vissza.</td>
          <td><a href="#date-maths">[html]</a></td>
        </tr>
        <tr>
          <td>MONTHNAME()</td>
          <td>A hónap nevét adja vissza.</td>
          <td><a href="#date-maths">[html]</a></td>
        </tr>
        <tr>
          <td>YEAR()</td>
          <td>Az adott évet adja vissza.</td>
          <td><a href="#date-maths">[html]</a></td>
        </tr>
        <tr>
          <td>HOUR()</td>
          <td>Az órát adja vissza.</td>
          <td><a href="#date-maths">[html]</a></td>
        </tr>
        <tr>
          <td>MINUTE()</td>
          <td>A percet adja vissza.</td>
          <td><a href="#date-maths">[html]</a></td>
        </tr>
        <tr>
          <td>SECOND()</td>
          <td>A másodpercet adja vissza.</td>
          <td><a href="#date-maths">[html]</a></td>
        </tr>
        <tr>
          <td>DATE_FORMAT()</td>
          <td>Dátum egyedi formázására használható. Két paramétert kell neki megadni: a dátumot és a formátumot, hogy miképp szeretnénk a dátumot visszakapni.</td>
          <td><a href="#date-maths">[html]</a><a href="https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_date-format">[mysql]</a></td>
        </tr>
        <tr>
          <td>DATEDIFF()</td>
          <td>Két dátum különbségét tudjuk vele kiszámolni. Két paramétert vár: a két dátumot, amelynek a különbségét meg szeretnénk kapni.</td>
          <td><a href="#date-maths">[html]</a></td>
        </tr>
        <tr>
          <td>DATE_ADD()</td>
          <td>Dátumhoz tudunk hozzáadni tetszőlegesen bármit, ami dátumhoz köthető. Például másodpercet vagy napokat.</td>
          <td><a href="#date-maths">[html]</a><a href="https://www.w3schools.com/sql/func_mysql_date_add.asp">[w3]</a></td>
        </tr>
        <tr>
          <td>CAST()</td>
          <td>Egy valamilyen típusú adatot másik típusú adattá tudunk konvertálni</td>
          <td><a href="#date-maths">[html]</a><a href="https://www.w3schools.com/sql/func_mysql_cast.asp">[w3]</a></td>
        </tr>
      </table>

      <h3>Logikai operátorok</h3>
      <table>
        <tr>
          <th>Kulcsszó</th>
          <th>Szerep</th>
          <th>Dokumentáció</th>
        </tr>
        <tr>
          <td>=, !=</td>
          <td>Egyenlő/nem egyenlő</td>
          <td><a href="#logical-operators">[html]</a></td>
        </tr>
        <tr>
          <td>LIKE, NOT LIKE</td>
          <td>Adatok illeszkedése vagy nem illeszkedése egy általunk megadott patternre</td>
          <td><a href="#logical-operators">[html-op]</a><a href="#finomitas">[html-fin]</a></td>
        </tr>
        <tr>
          <td>>, >=</td>
          <td>Nagyobb, nagyobb vagy egyenlő</td>
          <td><a href="#logical-operators">[html]</a></td>
        </tr>
        <tr>
          <td><, <=</td>
          <td>Kisebb, kisebb vagy egyenlő</td>
          <td><a href="#logical-operators">[html]</a></td>
        </tr>
        <tr>
          <td>AND, OR</td>
          <td>Logikai és, logikai vagy. Jelölésük még: && és ||</td>
          <td><a href="#logical-operators">[html]</a></td>
        </tr>
        <tr>
          <td>BETWEEN, NOT BETWEEN</td>
          <td>Egy adott érték két másik érték között van-e vagy sem.</td>
          <td><a href="#logical-operators">[html]</a></td>
        </tr>
        <tr>
          <td>IN, NOT IN</td>
          <td>Egy adott érték benne van-e egy halmazban vagy sem.</td>
          <td><a href="#logical-operators">[html]</a></td>
        </tr>
        <tr>
          <td>MOD</td>
          <td>Maradékos osztás. Jelölés még: %.</td>
          <td><a href="#logical-operators">[html]</a></td>
        </tr>
        <tr>
          <td>DIV</td>
          <td>Egészosztás. Jelölés még: /.</td>
          <td><a href="#logical-operators">[html]</a></td>
        </tr>
        <tr>
          <td>IS NULL, IS NOT NULL</td>
          <td>Logikai vizsgálat, hogy egy adat NULL-e vagy sem.</td>
          <td><a href="#logical-operators">[html]</a></td>
        </tr>
      </table>

      <h3>Elágazás</h3>
      <table>
        <tr>
          <th>Kulcsszó</th>
          <th>Szerep</th>
          <th>Dokumentáció</th>
        </tr>
        <tr>
          <td>CASE</td>
          <td>Ezzel jelöljük az elágazás kezdetét.</td>
          <td><a href="#logical-operators">[html]</a></td>
        </tr>
        <tr>
          <td>WHEN</td>
          <td>A feltételünket tudjuk megadni vele. A feltételek sorrendje nagyon fontos, hisz mindig a legkorábbi feltétel teljesül, ha van olyan feltétel, amire megfelel az adat.</td>
          <td><a href="#logical-operators">[html]</a></td>
        </tr>
        <tr>
          <td>THEN</td>
          <td>Ha teljesül a feltétel, akkor mit kapjunk vissza. Ez egy sorban van a WHEN-nel.</td>
          <td><a href="#logical-operators">[html]</a></td>
        </tr>
        <tr>
          <td>ELSE</td>
          <td>Amennyiben egyik feltétel sem teljesül, akkor mit kapjunk vissza.</td>
          <td><a href="#logical-operators">[html]</a></td>
        </tr>
        <tr>
          <td>END (AS)</td>
          <td>Az elágazás lezárása és az elágazás során kapott ideiglenes oszlop nevének meghatározása.</td>
          <td><a href="#logical-operators">[html]</a></td>
        </tr>
        <tr>
          <td>IF</td>
          <td>Feltételeket tudunk megadni és a feltétel teljesülése illetve nem teljesülése esetén tudunk bizonyos outputot meghatározni. Három paramétert vár: egy feltételt, egy értéket, amit akkor kapunk, ha igaz a feltétel, illetve egy értéket, amit akkor kapunk, ha nem teljesül az.</td>
          <td><a href="https://www.w3schools.com/sql/func_mysql_if.asp">[w3]</a></td>
        </tr>
        <tr>
          <td>IFNULL(feltetel, ertek)</td>
          <td>A NULL értékkel rendelkező adatnak tudunk értéket adni.</td>
          <td><a href="https://www.w3schools.com/sql/func_mysql_ifnull.asp">[w3]</a></td>
        </tr>
      </table>

      <h3>Joinok</h3>
      <table>
        <tr>
          <th>Kulcsszó</th>
          <th>Szerep</th>
          <th>Dokumentáció</th>
        </tr>
        <tr>
          <td>FOREIGN KEY, REFERENCES</td>
          <td>Foreign Key-jel két táblát tudunk összekötni úgy, hogy a kapcsolat megmaradjon. Ha táblát törlünk, akkor mindig a Foreign Key-es táblával kezdünk.</td>
          <td><a href="#joins">[html]</a></td>
        </tr>
        <tr>
          <td>INNER JOIN (JOIN)</td>
          <td>Az A és a B tábla azon rekordjai szerepelnek az összekapcsolt táblában, amelynek kulcsai az A és a B táblában is szerepelnek. Ez az egyetlen join, ahol nem lesz null érték (hacsak nem adtunk meg az egyik táblában null értéket).</td>
          <td><a href="#joins">[html]</a></td>
        </tr>
        <tr>
          <td>LEFT JOIN</td>
          <td>Amennyiben az A tábla kulcsa közül valamelyik szerepel a B tábla kulcsai között, úgy a B tábla adott rekordját hozzájoinoljuk a táblához. Az A tábla összes rekordja mindenképp bekerül a joinolt táblában, míg a B tábla azon rekordjait, amivel nem tudtunk matchelni, elhagyjuk. Lehet benne Null, amit az IFNULL() függvénnyel tudunk "feloldani".</td>
          <td><a href="#joins">[html]</a></td>
        </tr>
        <tr>
          <td>RIGHT JOIN</td>
          <td>Amennyiben a B tábla kulcsa közül valamelyik szerepel az A tábla kulcsai között, úgy az A tábla adott rekordját hozzájoinoljuk a táblához. A B tábla összes rekordja mindenképp bekerül a joinolt táblában, míg az A tábla azon rekordjait, amivel nem tudtunk matchelni, elhagyjuk. Lehet benne Null, amit az IFNULL() függvénnyel tudunk "feloldani".</td>
          <td><a href="#joins">[html]</a></td>
        </tr>
        <tr>
          <td>OUTER JOIN</td>
          <td>Az A és a B tábla összes rekordjai szerepelnek az összekapcsolt táblában, amelynek kulcsai az A vagy a B táblában szerepelnek. Azoknál a rekordoknál, amelyek eltérnek, null érték(ek) keletkeznek.</td>
          <td><a href="#joins">[html]</a></td>
        </tr>
        <tr>
          <td>ON DELETE CASCADE</td>
          <td>Ezt a FOREIGN KEY-nél tudjuk megadni és a célja az, hogyha egy rekordot törlünk a szülő táblában, akkor a gyerek táblában az összes hozzá tartozó rekordot töröljük, ugyanis azokra a rekordokra így már nem lesz szükségünk.</td>
          <td><a href="#joins">[html]</a></td>
        </tr>
      </table>

      <h3>Nézetek, módok</h3>
      <table>
        <tr>
          <th>Kulcsszó</th>
          <th>Szerep</th>
          <th>Dokumentáció</th>
        </tr>
        <tr>
          <td>CREATE VIEW ... AS ...</td>
          <td>Ezzel utasítással el tudjuk menteni az általunk megadott lekérdezés után kapott táblát. Ennek célja az, hogy bizonyos esetekben nem kell mégegyszer a lekérdezést megírni, hanem, mivel az elmentett tábla is normális táblaként funkcionál, könnyen hozzá tudunk férni az adott táblához és ugyanúgy tudunk lekérdezéseket is írni vele.</td>
          <td><a href="#views">[html]</a><a href="https://dev.mysql.com/doc/refman/8.0/en/create-view.html">[mysql]</a></td>
        </tr>
        <tr>
          <td>CREATE OR REPLACE VIEW ... AS ...</td>
          <td>Ha esetleg módosítani szeretnénk a táblán, például rossz sorrendben rendeztük, akkor használjuk ezt az utasítást.</td>
          <td><a href="#views">[html]</a><a href="https://dev.mysql.com/doc/refman/8.0/en/create-view.html">[mysql]</a></td>
        </tr>
        <tr>
          <td>ALTER VIEW</td>
          <td>Ugyanaz, mint az előző.</td>
          <td><a href="#views">[html]</a><a href="https://dev.mysql.com/doc/refman/8.0/en/alter-view.html">[mysql]</a></td>
        </tr>
        <tr>
          <td>HAVING</td>
          <td>A HAVING segítségével a csoportosított adatainkat tudjuk szűrni. A HAVING után tudjuk alkalmazni az <a href="#aggregate">összegző</a> függvényeket.</td>
          <td><a href="#views">[html]</a></td>
        </tr>
        <tr>
          <td>WITH ROLLUP</td>
          <td>A WITH ROLLUP kulcsszó a GROUP BY-jal áll együtt és ennek segítségével a lekérdezés során kapott táblázat utolsó sorában megjelenik egy összegző sor. Működik akkor is, ha több mezőt csoportosítunk, ekkor több összegző sor jelenik meg a legkérdezésben.</td>
          <td><a href="#views">[html]</a></td>
        </tr>
      </table>

      <h3>Ablakfüggvények</h3>
      <table>
        <tr>
          <th>Kulcsszó</th>
          <th>Szerep</th>
          <th>Dokumentáció</th>
        </tr>
        <tr>
          <td>OVER()</td>
          <td>Az OVER() függvény meghívásával tudjuk megvalósítani azt, hogy minden egyes sornál megjelenjen az összesítő függvény által számolt érték. Ha a zárójelek közé nem írunk semmit, akkor minden sornál ugyanaz az érték jelenik meg.</td>
          <td><a href="#windowfunctions">[html]</a><a href="https://dev.mysql.com/doc/refman/8.0/en/window-functions-usage.html">[mysql]</a></td>
        </tr>
        <tr>
          <td>PARTITION BY</td>
          <td></td>
          <td><a href="#windowfunctions">[html]</a><a href="https://dev.mysql.com/doc/refman/8.0/en/window-functions-usage.html">[mysql]</a></td>
        </tr>
        <tr>
          <td>ORDER BY</td>
          <td>AZ OVER() függvényt kell hozzá meghívni és a zárójel pár közé kell írni ezt a kulcsszót. A szerepe hasonlít a GROUP BY-éhoz, különböző sorokat tudunk csoportosítani az adott mezőben található értékeik szerint.</td>
          <td><a href="#windowfunctions">[html]</a><a href="https://dev.mysql.com/doc/refman/8.0/en/window-functions-usage.html">[mysql]</a></td>
        </tr>
        <tr>
          <td>RANK()</td>
          <td>A RANK() egy tényleges ablakfüggvény, amelynek segítségével rangsorolni tudjuk az adatainkat. Az OVER()-ben meg kell adni azt, hogy mi szerint szeretnénk rangsorolni. Fontos, hogy számít az, hogyha az adott értékek egyenlőek, ilyenkor ugyanolyan sorszámmal látja el az azonos értékkel rendelkező sorokat.</td>
          <td><a href="#windowfunctions">[html]</a><a href="https://dev.mysql.com/doc/refman/8.0/en/window-functions-usage.html">[mysql]</a></td>
        </tr>
        <tr>
          <td>ROW_NUMBER()</td>
          <td>A sorokat sorszámozza, nem törődik azzal, ha több adat is megegyezik egymással.</td>
          <td><a href="#windowfunctions">[html]</a><a href="https://dev.mysql.com/doc/refman/8.0/en/window-functions-usage.html">[mysql]</a></td>
        </tr>
        <tr>
          <td>DENSE_RANK()</td>
          <td>Hasonlít a RANK()-hez, annyi a különbség, hogy folyamatosan sorszámoz az egyenlőséget figyelembe véve.</td>
          <td><a href="#windowfunctions">[html]</a><a href="https://dev.mysql.com/doc/refman/8.0/en/window-functions-usage.html">[mysql]</a></td>
        </tr>
        <tr>
          <td>NTILE(N)</td>
          <td>Az adatokat N részre osztjuk bizonyos értékek szerint és azt kapjuk vissza minden sornál, hogy melyik részhez tartozik az adott adat az adott érték szerint.</td>
          <td><a href="#windowfunctions">[html]</a><a href="https://dev.mysql.com/doc/refman/8.0/en/window-functions-usage.html">[mysql]</a></td>
        </tr>
        <tr>
          <td>FIRST_VALUE()</td>
          <td>Az első érték.</td>
          <td><a href="#windowfunctions">[html]</a><a href="https://dev.mysql.com/doc/refman/8.0/en/window-functions-usage.html">[mysql]</a></td>
        </tr>
        <tr>
          <td>NTH_VALUE()</td>
          <td>Valahányadik érték.</td>
          <td><a href="#windowfunctions">[html]</a><a href="https://dev.mysql.com/doc/refman/8.0/en/window-functions-usage.html">[mysql]</a></td>
        </tr>
        <tr>
          <td>LAG()</td>
          <td>Összehasonlítás az előző sor értékével.</td>
          <td><a href="#windowfunctions">[html]</a><a href="https://dev.mysql.com/doc/refman/8.0/en/window-functions-usage.html">[mysql]</a></td>
        </tr>
        <tr>
          <td>LEAD()</td>
          <td>Összehasonlítás a következő sor értékével.</td>
          <td><a href="#windowfunctions">[html]</a><a href="https://dev.mysql.com/doc/refman/8.0/en/window-functions-usage.html">[mysql]</a></td>
        </tr>
      </table>
    </div>

    <div id="kezdetek">
      <h2>A kezdetek</h2>
      <p>SELECT * - minden rekord kiválasztása</p>
      <p>SELECT * FROM customers - minden rekord kiválasztása a customers adatbázisból</p>
      <p>ORDER BY Price DESC - Price szerint csökkenő sorrendbe (DESC) rendezzük az adatbázis rekordjait</p>
      <p>A kulcsszavak sorrendje:</p>
      <ol>
        <li>SELECT</li>
        <li>FROM</li>
        <li>WHERE</li>
        <li>GROUP BY</li>
        <li>HAVING</li>
        <li>ORDER BY</li>
      </ol>
    </div>

    <div id="adatbazisok">
      <h2>Adatbázisok, SQL, MySQL</h2>
      <p>Database management system (DBMS) - különböző szoftverek, amik segítségével adatbázisokat tudunk kezelni!</p>
      <p>database - a structured set of computerized data with an accessible interface</p>
      <p>SQL - structured query languages</p>
      <p>Az SQL-lel az adatbázissal kommunikálunk, míg a MySQL segítségével tudjuk az adatbázist változtatni</p>
    </div>

    <div id="tablazatok">
      <h2>Táblázatok</h2>
      <p>A táblázatok tetejét fejlécnek (header) nevezzük, ezekkel tudjuk megadni, hogy az adott oszlopban milyen adatok találhatóak meg (név, kor, nem stb.)</p>
      <p>Minden sorhoz 1-1 adat tartozik.</p>
      <p>Az adatbázisok táblázatok sokaságából áll.</p>
      <p>Rengeteg <a href="#adattipusok">adattípus</a> létezik, ezek közül kettő legfontosabb: INT (Numeric), VARCHAR (String)</p>
      <p>INT: Egész szám.</p>
      <p>VARCHAR: Különböző hosszúságú stringeket tudunk megadni, a hossza 1 és 255 között lehet. Zárójelben meg kell adni a maximum karakterhosszúságot. Pl.: varchar(100)</p>
    </div>

    <div id="tablazat-keszitese">
      <h2>Táblázat készítése és alapkulcsszavak</h2>
      <p>Először adatbázist kell létrehozni (ha még nincs), a CREATE DATABASE kulcsszó segítségével (az adatbázis neve nem állhat több szóból, ha több szót szeretnénk neki adni, használjuk a "snake_caset" vagy a "camelCaset").</p>
      <p>Utána a USE kulcsszó megadása után meg kell adni azt az adatbázist, amiben dolgozni szeretnénk.</p>
      <p>Ezek után lehet CREATE TABLE segítségével táblát létrehozni, ahol meg kell adni a tábla nevét és az összes mezőt a tulajdonságaikkal, ezeket vesszővel elválasztva.</p>
      <p>Az összes adatbázist a SHOW DATABASES-zel tudjuk lekérdezni. Az aktív adatbázisokat a SELECT DATABASE()-szel tudjuk lekérdezni, míg az adatbázisban található táblázatokat a SHOW TABLES kulcsszóval tudjuk lekérdezni.</p>
      <p>Egy adott tábla adataihoz a DESC kulcsszót kell használni.</p>
      <p>A SELECT DATABASE() kivételével minden kulcsszó után egy specifikus adatbázis/tábla nevet meg kell adni!</p>
      <p>DROP DATABASE/TABLE kulcsszavakkal adatbázist és táblázatot tudunk törölni, de vigyázni kell ezzel, mert a törlés végleges!</p>
      <p>Táblázatba értéket az INSERT INTO kulcsszóval tudunk beilleszteni. Ezután meg kell adni a táblázat nevét és a mezőket, ahová adatot adunk meg, majd a VALUES kulcsszó után zárójelben, a megfelelő sorrendben és vesszővel elválasztva akár több adatot is meg tudunk adni.</p>
    </div>

    <div id="null">
      <h2>NOT vs NOT NULL, default érték</h2>
      <p>NULL - Az értékét nem ismerjük, nincs meghatározott értéke és nem ekvivalens a nullával.</p>
      <p>1. eset: NULL és nincs default érték</p>
      <img src="../img/mysql/Kép1.jpg" alt="">
      <p>Ha valaminek nem adunk értéket a táblázatba hozzáadásnál, akkor az default NULL értéket kap.</p>
      <img src="../img/mysql/Kép2.jpg" alt="">
      <hr>
      <p>2. eset: NOT NULL és nincs default érték</p>
      <p>A NOT NULL megadásával elkerülhetjük a NULL értékeket.</p>
      <p>NOT NULL megadásához a táblázat készítésekor meg kell adni az adattípus után, hogy NOT NULL.</p>
      <img src="../img/mysql/Kép3.jpg" alt="">
      <p>Amennyiben megadjuk a NOT NULL-t és valamihez nem rendelünk értéket, akkor az INT helyére 0 kerül, míg a VARCHAR helyére üres string.</p>
      <img src="../img/mysql/Kép4.jpg" alt="">
      <p>Ezt kikerülve meg kell adnunk egy default értéket.</p>
      <hr>
      <p>3. eset: NULL és van default érték</p>
      <p>Default értéket úgy tudunk megadni, hogy az adattípus megadása után a DEFAULT kulcsszó után megadunk egy értéket (pl. DEFAULT 'unnamed').</p>
      <img src="../img/mysql/Kép5.jpg" alt="">
      <p>Ha valamihez nem rendelünk értéket, akkor automatikusan a default érték kerül megadásra.</p>
      <img src="../img/mysql/Kép6.jpg" alt="">
      <hr>
      <p>4. eset: NOT NULL és van default érték</p>
      <p>Nagyon hasonlít a 3. esethez, DE a 3. esetben tudunk manuálisan NULL értéket adni. Ha megadjuk, hogy NOT NULL a táblázat készítésénél, akkor egy NULL érték megadásánál errort kapunk.</p>
      <img src="../img/mysql/Kép7.jpg" alt="">
      <p>És ha NULL értéket szeretnénk beilleszteni a táblázatban, ezt kapjuk: <br>
        ERROR 1048 (23000): Column 'age' cannot be null</p>
      <p>Összességében a lényeg: Ha egy adat megadása kötelező, akkor NOT NULL, ha nem kötelező, akkor NULL</p>
      <p>
        Idézőjelek: Ha a szövegben ' található, akkor hibát kaphatunk. Ilyenkor a szövegünket vagy "" közé írjuk, vagy használjuk a \'-t.</p>
    </div>

    <div id="primary-keys">
      <h2>Kulcsok - Primary Keys</h2>
      <p>Előfordulhat az az eset, hogy több adathoz pontosan ugyanazokat a tulajdonságokat adjuk meg, például:</p>
      <img src="../img/mysql/Kép8.jpg" alt="">
      <p>Ez miért probléma? Alapvetően a fő cél az, hogy minden egyes adat az adatbázisban (és a táblákban) egyedi legyen, kerülni kell az azonos adatokat. Nincs arra lehetőség, hogy ezeket az adatokat elszeparáljuk és különbözőként tekintsünk rájuk.</p>
      <p>Ezt a problémát úgy tudjuk kiküszöbölni, hogy minden egyes adatot egy egyedi ID-val látunk el.</p>
      <h3>Primary key - a unique identifier</h3>
      <p>Kulcsot úgy tudunk megadni, ha a táblázat készítésénél a PRIMARY KEY után zárójelben megadjuk, hogy melyik mező viselkedjen kulcsként. Vagy az adott mező végére írjuk oda, hogy PRIMARY KEY.</p>
      <p>Ezután pedig minden egyes új adat bevitelekor az adatok mellé egy ID-t is meg tudunk adni, amiket nem tudunk duplikálni, mert errort kapunk.</p>
      <img src="../img/mysql/Kép9.jpg" alt="">
      <p>Amennyiben azt szeretnénk, hogy ez az ID folyamatosan növekedjen, a táblázat megadásakor meg kell adni az AUTO_INCREMENT-et is.</p>
      <img src="../img/mysql/Kép10.jpg" alt="">
    </div>

    <div id="crud">
      <h2>CRUD</h2>
      <p>A négy legfontosabb művelet:</p>
      <ul style="list-style: none;">
        <li>Create - INSERT INTO</li>
        <li>Read - Adatok kiolvasása</li>
        <li>Update - Adatok frissítése</li>
        <li>Delete - Adatok törlése</li>
      </ul>
      <h3>Read</h3>
      <p class="p-bold">Hogyan tudjuk megkapni és megkeresni az adatokat?</p>
      <p>*-gal az összes oszlopot visszakapjuk (vagyis a teljes táblát)</p>
      <p>Ha csak bizonyos oszlopokat szeretnénk kiíratni, akkor a SELECT kulcsszó után a megfelelő oszlopneveket kell megadni vesszővel elválasztva (pl SELECT name, age). Az oszlopok sorrendje is az lesz, ahogy megadtuk őket a SELECT után.</p>
      <p>Ált.: <br>
        SELECT {mezok} <br>
        FROM {tabla};</p>
      <br>
      <p>Például: <br>
        SELECT name, age <br>
        FROM cats;</p>
      <img src="../img/mysql/Kép11.jpg" alt="">
      <p>A WHERE kulcsszóval bizonyos feltételeket tudunk adni, amelyekkel tudjuk szűkíteni a visszaadandó adatok méretét, ezáltal sokkal specifikusabban tudjuk megadni a lekérdezést. A nagybetű/kisbetű nem számít.</p>
      <p>Ált.: <br>
        SELECT {mezok} <br>
        FROM {tabla} <br>
        WHERE {feltetel};</p>
      <br>
      <p>Például: <br>
        SELECT * <br>
        FROM cats <br>
        WHERE age >= 5;</p>
      <img src="../img/mysql/Kép12.jpg" alt="">
      <p>Példa egy összetettebb lekérdezésre: <br>
        SELECT name <br>
        FROM cats <br>
        WHERE age >= 5 AND breed = 'Maine Coon';</p>
      <img src="../img/mysql/Kép13.jpg" alt="">
      <p>ALIAS - AS kulcsszó, ezzel meg tudjuk adni, hogy az adott mező milyen néven jelenjen meg. Ez azért is nagyon fontos, mert ha több táblát kapcsolunk össze, amelyek ugyanazokkal a mezőnevekkel rendelkeznek (pl name), akkor abból kavarodás lehet. A több szóból álló aliast idézőjelek közé kell tenni.</p>
      <p>Ált.: <br>
        SELECT {mezo} AS {mezo_alias}, ... <br>
        FROM {tabla};</p>
      <br>
      <p>Például: <br>
        SELECT cat_id AS id, name <br>
        FROM cats <br>
        WHERE age > 3;</p>
      <img src="../img/mysql/Kép14.jpg" alt="">
      <p>És ahogy látható, a cat_id-ből id lett.</p>
      <h3>Update</h3>
      <p class="p-bold">Az adatok felülírása</p>
      <p>UPDATE kulcsszó után meg kell adni a tábla nevét, majd egy SET kulcsszó után, hogy melyik mezőben szeretnénk módosítani és milyen értékre. Ezután a WHERE kulcsszóval meg kell adni a feltételt és az összes feltételt teljesítő rekordra módosítjuk a SET után megadott mezőt arra az értékre.</p>
      <p>Érdemes az update előbb SELECT-tel kiválasztani a megváltozandó adatot vagy adatokat, hogyha esetleg rosszul updateltünk, akkor lássuk a hibát.</p>
      <p>Ált.: <br>
        UPDATE {tabla} <br>
        SET {modositas} <br>
        WHERE {feltetel};</p>
      <br>
      <p>Például: <br>
        UPDATE cats <br>
        SET breed='Shorthair' <br>
        WHERE breed='Tabby';</p>
      <img src="../img/mysql/Kép15.jpg" alt="">
      <p>Ahogy látható, a Tabbyből Shorthair lett.</p>
      <h3>Delete</h3>
      <p class="p-bold">Adatok törlése.</p>
      <p>DELETE kulcsszó után FROM kulcsszó, amit a táblanév követ, majd a WHERE kulcsszó után meg kell adni a feltételt, ami alapján adatot szeretnénk törölni. Törlés előtt célszerű SELECT-tel lekérdezni a törölni kívánt adatot, mert a törlést nem tudjuk visszavonni.</p>
      <p>Ált.: DELETE FROM {tabla} WHERE {feltetel};</p>
      <p>A feltétel nélküli DELETE az összes adatot kitörli a táblázatból. Van különbség eközött és a DROP TABLE között, ugyanis az előbbi az adatokat törli (de a táblázat megmarad), míg utóbbi a teljes táblát.</p>
      <p>DELETE FROM cats WHERE age=4; <br>
        DELETE FROM cats WHERE cat_id=age;</p>
      <img src="../img/mysql/Kép16.jpg" alt="">
    </div>

    <div id="sql-programok">
      <h2>SQL programok írása</h2>
      <p>SQL programok kiterjesztése: .sql</p>
      <p>ls-sel meg kell nézni, hogy látjuk-e az adott könyvtárban az .sql filet. Ha igen, akkor jó helyen járunk.</p>
      <p>Terminalban a source + fájlnév megadása után tudunk SQL-t futtatni.</p>
      <p><a href="https://www.w3schools.com/mysql/mysql_ref_functions.asp">MySQL függvények</a></p>
    </div>

    <div id="string-functions">
      <h2>MySQL string függvények</h2>
      <p>Főbb függvények:</p>
      <ul style="list-style: none;">
        <li>CONCAT</li>
        <li>SUBSTRING</li>
        <li>REPLACE</li>
        <li>REVERSE</li>
        <li>CHAR_LENGTH</li>
        <li>UPPER</li>
        <li>LOWER</li>
      </ul>
      <p>Ezeket a függvényeket csak SELECT-tel tudjuk alkalmazni, mert error-t kapunk.</p>
      <h3>CONCAT</h3>
      <p class="p-bold">Több szöveget egy szöveggé alakítunk</p>
      <p>Ált.: CONCAT(x,y,z,...)</p>
      <p>Ált.: CONCAT(column1, 'text', column2, 'text', ...)</p>
      <p>A CONCAT függvényt a SELECT kulcsszó után tudjuk használni és ha mezőket szeretnénk összefűzni, akkor meg kell adni a tábla nevét is.</p>
      <p>SELECT CONCAT(author_fname, ' ', author_lname) <br>
        FROM books <br>
        WHERE pages > 400;</p>
      <img src="../img/mysql/Kép17.jpg" alt="">
      <p>Ekkor egy elég hosszú és csúnya mezőnevet kapunk. Ezt elkerülve használjunk alias-t (AS kulcsszó)!</p>
      <p>SELECT CONCAT(author_fname, ' ', author_lname) AS author <br>
        FROM books <br>
        WHERE pages > 400;</p>
      <img src="../img/mysql/Kép18.jpg" alt="">
      <p>Több mezőt is ki tudunk iratni természetesen úgy, hogy az egyik mezőt konkatenáljuk!</p>
      <p>SELECT author_fname AS first, author_lname AS last, CONCAT(author_fname, ' ', author_lname) AS author <br>
        FROM books <br>
        WHERE pages > 400;</p>
      <img src="../img/mysql/Kép19.jpg" alt="">
      <p>De természetesen a CONCATOT feltételként is tudjuk alkalmazni.</p>
      <p>SELECT title <br>
        FROM books <br>
        WHERE CONCAT(author_fname, ' ', author_lname)='Jhumpa Lahiri';</p>
      <img src="../img/mysql/Kép20.jpg" alt="">
      <p>CONCAT_WS - több szöveget egy szöveggé gyúrunk, az elején megadott elválasztó karakter minden mező között megjelenik</p>
      <p>Ált.: CONCAT_WS(elv., x, y, z, ...)</p>
      <p>SELECT CONCAT_WS(' - ', title, author_fname, author_lname) AS book <br>
        FROM books <br>
        WHERE pages > 400;</p>
      <img src="../img/mysql/Kép21.jpg" alt="">
      <h3>SUBSTRING</h3>
      <p class="p-bold">A szöveg bizonyos részeit ki tudjuk vágni.</p>
      <p>Például: SELECT SUBSTRING('Hello World', 1, 4);</p>
      <img src="../img/mysql/Kép22.jpg" alt="">
      <p>Ált.: SUBSTRING(string, x) - ebben az esetben az X. karaktertől kezdődően az összes karakter benne lesz a vágásban. Az x lehet negatív, ebben az esetben az utolsó x karaktert kapjuk vissza.</p>
      <p>SELECT SUBSTRING('Hello World', -3);</p>
      <img src="../img/mysql/Kép23.jpg" alt="">
      <p><strong>A karakterek számolását 1-től kezdjük!</strong></p>
      <p>Hasonlóan a CONCAT-hoz, a SUBSTRINGET is csak SELECT után tudjuk megadni, ha mezőkre hivatkozunk, ugyanúgy kell a FROM tablanev!</p>
      <p>SELECT SUBSTRING(title, 1, 10) AS 'short title' <br>
        FROM books <br>
        WHERE pages > 350;</p>
      <img src="../img/mysql/Kép24.jpg" alt="">
      <p>Hasonlóan a CONCAT-hoz, a SUBSTRING-et is bele tudjuk építeni feltételbe.</p>
      <p>SELECT title <br>
        FROM books <br>
        WHERE SUBSTRING(title, 1, 1)='A';</p>
      <img src="../img/mysql/Kép25.jpg" alt="">
      <p>Létezik a SUBSTRING-nek egy shortcut-ja, a SUBSTR, ami ugyanúgy működik, mint a hosszabb változata.</p>
      <p>A CONCAT-ot és a SUBSTRING-et tudjuk kombinálni is:</p>
      <p>SELECT CONCAT(SUBSTR(title, 1, 10), '...') AS 'short title' <br>
        FROM books <br>
        WHERE pages > 350;</p>
      <img src="../img/mysql/Kép26.jpg" alt="">
      <h3>REPLACE</h3>
      <p class="p-bold">A szöveg egy részeit kicseréljük.</p>
      <p>Ált.: REPLACE(szöveg, a cserélendő szövegrészlet, a helyettesített szövegrészlet)</p>
      <p>Ugyanúgy, kell a SELECT, hogy tudjuk alkalmazni. <strong>A cserélendő szöveg érzékeny a kis- és nagybetűkre!</strong></p>
      <p>Például: <br>
        SELECT REPLACE(title, 'a', 4) AS a4 <br>
        FROM books <br>
        WHERE pages > 350;</p>
      <img src="../img/mysql/Kép27.jpg" alt="">
      <p>A REPLACE-t is tudjuk kombinálni a CONCAT-tal és a SUBSTRING-gel!</p>
      <p>SELECT CONCAT(SUBSTRING(REPLACE(title, 'e', 3),1,10),'...') AS e3 <br>
        FROM books <br>
        WHERE pages > 350;</p>
      <img src="../img/mysql/Kép28.jpg" alt="">
      <h3>REVERSE</h3>
      <p class="p-bold">Szövegek megfordítása</p>
      <p>Ált.: REPLACE(string)</p>
      <p>Szintén a SELECT után tudjuk megadni.</p>
      <p>SELECT REVERSE(title) AS eltit <br>
        FROM books <br>
        WHERE pages > 350;</p>
      <img src="../img/mysql/Kép29.jpg" alt="">
      <p>Ugyanúgy tudjuk a többi függvénnyel kombinálni.</p>
      <p>SELECT CONCAT(title, ' | ', REVERSE(title)) AS palindrome <br>
        FROM books <br>
        WHERE stock_quantity > 30 AND stock_quantity < 50;</p>
      <img src="../img/mysql/Kép30.jpg" alt="">
      <h3>CHAR_LENGTH</h3>
      <p class="p-bold">Karakterhosszúsága egy stringnek</p>
      <p>Ált.: CHAR_LENGTH(string)</p>
      <p>Szintén SELECT kulcsszó kell a használatához.</p>
      <p>SELECT CHAR_LENGTH(author_lname) AS last_length <br>
        FROM books <br>
        WHERE pages > 350;</p>
      <img src="../img/mysql/Kép31.jpg" alt="">
      <p>Használhatjuk szintén feltételként.</p>
      <p>SELECT title, author_fname, author_lname <br>
        FROM books <br>
        WHERE CHAR_LENGTH(title) < 15;</p>
      <img src="../img/mysql/Kép32.jpg" alt="">
      <p>A CHAR_LENGTH-et is össze tudjuk kombinálni a többi string művelettel.</p>
      <p>SELECT title, CHAR_LENGTH(CONCAT(author_fname, ' ', author_lname)) AS author_length <br>
        FROM books <br>
        WHERE pages > 350;</p>
      <img src="../img/mysql/Kép33.jpg" alt="">
      <h3>UPPER és LOWER</h3>
      <p class="p-bold">Megváltoztatja az összes karaktert nagy- vagy kisbetűre.</p>
      <p>Például: SELECT UPPER('Hello World') AS HELLO;</p>
      <img src="../img/mysql/Kép34.jpg" alt="">
      <p>SELECT LOWER('Hello World') AS hello;</p>
      <img src="../img/mysql/Kép35.jpg" alt="">
      <p>SELECT title, UPPER(CONCAT(author_fname, ' ', author_lname)) AS author_upper <br>
        FROM books <br>
        WHERE pages > 350;</p>
      <img src="../img/mysql/Kép36.jpg" alt="">
      <p>SELECT title, LOWER(CONCAT(author_fname, ' ', author_lname)) AS author_lower <br>
        FROM books <br>
        WHERE pages > 350;</p>
      <img src="../img/mysql/Kép37.jpg" alt="">
    </div>

    <div id="finomitas">
      <h2>A lekérdezett adatok finomítása</h2>
      <ul style="list-style: none;">
        <li>DISTINCT - duplikált adatok kiszűrése</li>
        <li>ORDER BY - sorbarendezés</li>
        <li>LIMIT - lekérdezés limitálása (és elcsúsztatása)</li>
        <li>LIKE - keresés részszóra vagy bizonyos patternre</li>
      </ul>
      <h3>DISTINCT</h3>
      <p class="p-bold">Ha egy adatból több található a táblában, akkor csak egyszer kapjuk vissza.</p>
      <p>A SELECT kulcsszóval áll együtt és ugyanúgy történik a lekérdezés, mint "normális" esetben.</p>
      <p>SELECT DISTINCT author_lname <br>
        FROM books;</p>
      <img src="../img/mysql/Kép38.jpg" alt="">
      <p>Viszont a DISTINCT nem feltétlenül túl specifikus. Nem tudhatjuk, hogy több azonos vezetéknév nem takar-e például két különböző embert. Ennél sokkal specifikusabban kell megadni a szűkítést. Ha több mezőnevet is vissza szeretnénk kapni, akkor a DISTINCT adatonként az összes mezőre elvégzi a megegyező adatok szűrését, így ha például valakiknek azonos a vezetéknevük, de a keresztnevük nem, akkor nem kerülnek ki a lekérdezett adatok közül.</p>
      <p>SELECT DISTINCT author_fname, author_lname <br>
        FROM books;</p>
      <img src="../img/mysql/Kép39.jpg" alt="">
      <h3>ORDER BY</h3>
      <p class="p-bold">Az eredmények sorbarendezése.</p>
      <p>A sorbarendezés default növekvő sorrendben rendez, de meg tudjuk adni, hogy növekvő vagy csökkenő sorrendben legyenek-e az adataink. Ehhez az ASC és a DESC kulcsszavakra lesz szükségünk, amit a mező neve után kell megadni.</p>
      <p>A sorbarendezés működik szövegre és számra egyaránt. Olyan mező alapján is sorba tudunk rendezni, amit nem íratunk ki.</p>
      <p>SELECT DISTINCT author_fname, author_lname <br>
        FROM books <br>
        ORDER BY author_lname;</p>
      <img src="../img/mysql/Kép40.jpg" alt="">
      <p>Ha viszont az ORDER BY után számot írunk, nem mezőnevet, akkor aszerint a mező szerint rendezünk, amelyik az adott helyen áll a kiválasztott mezők között. A lenti példán például a 2. mező szerint rendezünk növekvő sorrendben.</p>
      <p>SELECT title, author_fname, author_lname <br>
        FROM books <br>
        WHERE pages > 350 <br>
        ORDER BY 2;</p>
      <img src="../img/mysql/Kép41.jpg" alt="">
      <p>Az ORDER BY után több mező nevét is meg tudjuk adni, ilyenkor mindig a legelső sorbarendezés hajtódik végre, utána a második és így tovább.</p>
      <p>SELECT author_fname, author_lname <br>
        FROM books <br>
        ORDER BY author_lname ASC, author_fname DESC;</p>
      <img src="../img/mysql/Kép42.jpg" alt="">
      <p>(És természetesen ez utóbbi működik a számos módszerrel is!)</p>
      <h3>LIMIT</h3>
      <p class="p-bold">A kiírandó rekordok számát tudjuk ezzel korlátozni.</p>
      <p>A LIMIT a lekérdezés legvégére kerül. A kulcsszó után egy számot kell írni, amellyel azt adjuk meg, hogy legfeljebb hány rekordot szeretnénk lekérdezni.</p>
      <p>SELECT title <br>
        FROM books <br>
        LIMIT 5;</p>
      <img src="../img/mysql/Kép43.jpg" alt="">
      <p>Természetesen kicsit bonyolultabb lekérdezéseknél is tudjuk használni a LIMIT-et.</p>
      <p>SELECT CONCAT(author_fname, ' ' , author_lname) AS author, title, released_year AS year <br>
        FROM books <br>
        WHERE pages > 150 <br>
        ORDER BY released_year <br>
        LIMIT 5;</p>
      <img src="../img/mysql/Kép44.jpg" alt="">
      <p>Van egy olyan megadási módja is a LIMIT-nek, hogy két számot írunk utána vesszővel elválasztva: az 1. az az eltolás mértéke (vagyis az első rekord, amit visszakapunk, 0-tól számolva), míg a második a limit lesz. Ha az x. sortól szeretnénk az összes eredményt kiíratni, akkor az első értéknek x-et, a második értéknek pedig egy hatalmas számot kell megadni.</p>
      <p>A fenti példa úgy, hogy a LIMIT kulcsszó után 1,5-t adunk meg:</p>
      <p>SELECT CONCAT(author_fname, ' ' , author_lname) AS author, title, released_year AS year <br>
        FROM books <br>
        WHERE pages > 150 <br>
        ORDER BY released_year <br>
        LIMIT 1,5;</p>
      <img src="../img/mysql/Kép45.jpg" alt="">
      <p>Látható, hogy az 1. rekord, amit visszakapunk az a másik lekérdezésnél a 2. volt.</p>
      <h3>LIKE</h3>
      <p class="p-bold">Bizonyos szövegrészletek keresése (például első karakter alapján).</p>
      <p>Ált.: SELECT * FROM {tabla} WHERE {mezo} LIKE '%{valami}'; - az elején van egyezés</p>
      <p>Ált.: SELECT * FROM {tabla} WHERE {mezo} LIKE '%{valami}%'; - bárhol megtalálható az általunk megadott részszó</p>
      <p>Ált.: SELECT * FROM {tabla} WHERE {mezo} LIKE '%{valami}'; - a végén van egyezés</p>
      <p>Ált.: SELECT * FROM {tabla} WHERE {mezo} LIKE '%{valami1}%{valami2}%...' - több szövegrészlet között bármilyen karakter állhat, akkor van egyezés, ha ez a pattern illeszkedik valamelyik rekord adott mezőjére</p>
      <p>Ált.: SELECT * FROM {tabla} WHERE {mezo} LIKE '____' - az aláhúzás pontosan 1 karaktert jelöl, olyan hosszú rekordokat keresünk az adott mezőben, ami olyan hosszú, ahány aláhúzást adtunk meg</p>
      <p><strong>(A % akármennyi karakter, míg az _ csak 1 karakter jelölése!)</strong></p>
      <p>Nagyon fontos az, hogy a LIKE kulcsszó a WHERE-rel áll együtt méghozzá úgy, hogy a WHERE és a LIKE közé meg kell adni annak a mezőnek a nevét, ahol szeretnénk szövegrészletre keresni.</p>
      <p><strong>1. eset:</strong><br>
        SELECT title, author_fname, author_lname <br>
        FROM books <br>
        WHERE author_fname <br>
        LIKE 'da%';</p>
      <img src="../img/mysql/Kép46.jpg" alt="">
      <p>Ahogy itt is látható, az összes olyan rekordot visszakaptuk, ahol az író keresztneve 'da'-val kezdődik.</p>
      <br>
      <p><strong>2. eset:</strong><br>
        SELECT title, author_fname, author_lname <br>
        FROM books <br>
        WHERE author_fname <br>
        LIKE '%da%';</p>
      <img src="../img/mysql/Kép47.jpg" alt="">
      <p>Ahogy itt is látható, az összes olyan rekordot visszakaptuk, ahol az író keresztnevében van 'da' részszó.</p>
      <br>
      <p><strong>3. eset:</strong><br>
        SELECT title, author_fname, author_lname <br>
        FROM books <br>
        WHERE author_fname <br>
        LIKE '%da';</p>
      <img src="../img/mysql/Kép48.jpg" alt="">
      <p>Ahogy itt is látható, az összes olyan rekordot visszakaptuk, ahol az író keresztneve 'da'-val végződik.</p>
      <br>
      <p><strong>4. eset:</strong><br>
        SELECT title, author_fname, author_lname <br>
        FROM books <br>
        WHERE title <br>
        LIKE '%the%a%';</p>
      <img src="../img/mysql/Kép49.jpg" alt="">
      <p>Ennél a példánál visszakaptuk az összes olyan könyvcímet, amiben megtalálható a %the%a% pattern.</p>
      <p>SELECT title, author_fname, author_lname <br>
        FROM books <br>
        WHERE title <br>
        LIKE '%the%a%no%';</p>
      <img src="../img/mysql/Kép50.jpg" alt="">
      <p>Ennél a példánál visszakaptuk az összes olyan könyvcímet, amiben megtalálható a %the%a%no% pattern.</p>
      <br>
      <p><strong>5. eset:</strong><br>
        SELECT title, CONCAT(author_fname, ' ', author_lname) AS author, stock_quantity AS quantity <br>
        FROM books <br>
        WHERE stock_quantity <br>
        LIKE '___' <br>
        ORDER BY 3;</p>
      <img src="../img/mysql/Kép51.jpg" alt="">
      <p>Itt pedig minden olyan rekordot visszakaptunk, ahol a darabszám egy háromjegyű szám (mivel 3 aláhúzás van!)</p>
      <p>De mi van abban az esetben ha a könyv címében % vagy _ van? A megoldás egyszerű: ha %-ra vagy _-ra keresünk, akkor az adott jel elé \-t kell tenni.</p>
      <p>SELECT title, author_fname, author_lname <br>
        FROM books <br>
        WHERE title <br>
        LIKE '%\%%';</p>
      <img src="../img/mysql/Kép52.jpg" alt="">
      <p>Megkaptuk ezzel az összes könyvet, amiben % van.</p>
      <p>Ennél a pontnál a kódok megtalálhatóak a MySQL-ben elmentve.</p>
    </div>

    <div id="aggregate">
      <h2>Összegző (aggregate) függvények és adatok csoportosítása</h2>
      <ul style="list-style: none;">
        <li>COUNT() - megszámlálás</li>
        <li>GROUP BY - csoportosítás</li>
        <li>MIN() - minimum</li>
        <li>MAX() - maximum</li>
        <li>SUM() - összeg</li>
        <li>AVG() - átlag</li>
      </ul>
      <h3>COUNT</h3>
      <p class="p-bold">Adatok összeszámolására való.</p>
      <p>A COUNT kulcsszót közvetlenül a SELECT kulcsszó után kell megadni, majd zárójelben a megszámlálandó mező vagy mezők nevét kell megadni.</p>
      <p>SELECT COUNT(author_fname) <br>
        FROM books;</p>
      <img src="../img/mysql/Kép53.jpg" alt="">
      <p>Amennyiben csak az egyedi rekordokat szeretnénk összeszámolni, úgy a COUNT-on belül meg kell adni a DISTINCT kulcsszót, közvetlenül a megszámolandó mezőnév előtt.</p>
      <p>SELECT COUNT(DISTINCT author_fname) <br>
        FROM books;</p>
      <img src="../img/mysql/Kép54.jpg" alt="">
      <p>Természetesen lehetőségünk van COUNT-on belül bármelyik string függvényt is alkalmazni, például a CONCAT-ot, ha mondjuk azt szeretnénk, hogy hány író található az adatbázisban.</p>
      <p>SELECT COUNT(DISTINCT CONCAT(author_fname, ' ', author_lname)) AS no_of_author <br>
        FROM books;</p>
      <img src="../img/mysql/Kép55.jpg" alt="">
      <p>De ugyanez megadható CONCAT nélkül is:</p>
      <p>SELECT COUNT(DISTINCT author_fname, author_lname) AS no_of_author <br>
        FROM books;</p>
      <img src="../img/mysql/Kép56.jpg" alt="">
      <p>Az előbb látott LIKE-ot is kombinálhatjuk a COUNT-tal, ekkor azt a számot kapjuk meg, hogy hány rekord felel meg az általunk megadott patternnek.</p>
      <p>SELECT COUNT(title) <br>
        FROM books <br>
        WHERE title <br>
        LIKE "%the%";</p>
      <img src="../img/mysql/Kép57.jpg" alt="">
      <h3>GROUP BY</h3>
      <p class="p-bold">Megegyező adatok csoportosítása egyetlen sorba.</p>
      <p>A GROUP BY kulcsszót közvetlenül a WHERE kulcsszó után kell írni (amennyiben van), a GROUP BY után annak a mezőnek a nevét kell megadni, ami alapján szeretnénk csoportosítani. Általában az(oka)t a mező(ke)t szeretnénk lekérdezni, ami(k) alapján csoportosítunk és ez(ek) mellé valamelyik összegző függvényt is kell alkalmaznunk.</p>
      <p>SELECT author_lname, COUNT(*) <br>
        FROM books <br>
        GROUP BY author_lname;</p>
      <img src="../img/mysql/Kép58.jpg" alt="">
      <p>Amennyiben viszont szeretnénk azt a problémát elkerülni, hogy például valakinek ugyanaz a vezetékneve, de más ember, akkor több mezőt is meg tudunk adni a GROUP BY-nál.</p>
      <p>SELECT author_fname, author_lname, COUNT(*) <br>
        FROM books <br>
        GROUP BY author_fname, author_lname;</p>
      <img src="../img/mysql/Kép59.jpg" alt="">
      <p>Ekkor ugyanazt az eredményt kapjuk, mint az előbb, kiegészülve a keresztnevekkel. Ez így már egy sokkal specifikusabb csoportosítás!</p>
      <h3>MIN és MAX</h3>
      <p class="p-bold">Visszaadja a legkisebb/legnagyobb értéket</p>
      <p>GROUP BY nélkül úgy adhatjuk meg őket, mint a COUNTOT: SELECT után jön a MIN/MAX és zárójelben annak a mezőnek a neve, ahol a minimumot keressük. Ez a két függvény működik szövegre is, ekkor az ABC-ben a legelőrébb/leghátrébb lévő szöveget kapjuk vissza.</p>
      <p>SELECT MIN(released_year) <br>
        FROM books;</p>
      <img src="../img/mysql/Kép60.jpg" alt="">
      <p>SELECT MAX(title) <br>
        FROM books;</p>
      <img src="../img/mysql/Kép61.jpg" alt="">
      <p>Vannak problémák ezekkel a függvényekkel. Például ha kiíratjuk a legnagyobb oldalszámot és mellé a könyvcímet, akkor nem feltétlenül lesz egyezés.</p>
      <p>SELECT MAX(pages), title <br>
        FROM books;</p>
      <img src="../img/mysql/Kép62.jpg" alt="">
      <p>Való igaz, hogy a leghosszabb könyv 790 oldalas, de az nem a The Namesake, hanem a Software Engineering.</p>
      <p>A probléma egyik lehetséges kiküszöbölése az úgynevezett subquery (allekérdezés) használata. Ez úgy működik, hogy a feltételben megadunk egy SELECT-et és ez a SELECT fog előbb végrehajtódni. Például:</p>
      <p>SELECT pages, title <br>
        FROM books <br>
        WHERE pages = (SELECT MAX(pages) FROM books);</p>
      <img src="../img/mysql/Kép63.jpg" alt="">
      <p>Viszont ennél a nagy probléma az lehet, hogy nagy adatbázisra 2x futtatjuk le a lekérdezést, ami viszonylag időigényes.</p>
      <p>SELECT author_fname, author_lname, MIN(released_year) <br>
        FROM books <br>
        GROUP BY author_fname, author_lname <br>
        ORDER BY 2, 1;</p>
      <img src="../img/mysql/Kép64.jpg" alt="">
      <p>Ennél a lekérdezésnél az egyes írók legkorábbi művét kaptuk meg.</p>
      <h3>SUM</h3>
      <p class="p-bold">Összegzés.</p>
      <p>Hasonlít a többi függvényhez: SELECT után tudjuk megadni és meg kell adni, hogy mely mezőket szeretnénk összegezni. Szövegekre is működik, csak semmi értelme alkalmazni.</p>
      <p>SELECT SUM(pages) <br>
        FROM books;</p>
      <img src="../img/mysql/Kép65.jpg" alt="">
      <p>SELECT author_fname, author_lname, SUM(pages) <br>
        FROM books <br>
        GROUP BY author_fname, author_lname <br>
        ORDER BY 2, 1;</p>
      <img src="../img/mysql/Kép66.jpg" alt="">
      <p>Ennél a lekérdezésnél pedig egyes írók által írt művek össz oldalszámait kapjuk meg.</p>
      <h3>AVG</h3>
      <p class="p-bold">Átlagolás.</p>
      <p>SELECT után adjuk meg, mint a társait és szintén meg kell adni, hogy mely mezőket szeretnénk átlagolni.</p>
      <p>A számok decimálisak, a tizedesvessző után 4 számjegyet ír ki alapértelmezetten az SQL.</p>
      <p>SELECT AVG(pages) <br>
        FROM books;</p>
      <img src="../img/mysql/Kép67.jpg" alt="">
      <p>SELECT released_year, AVG(stock_quantity) <br>
        FROM books <br>
        GROUP BY released_year <br>
        ORDER BY 1;</p>
      <img src="../img/mysql/Kép68.jpg" alt="">
      <p>Ezzel megkapjuk az átlagos raktáron lévő darabszámokat az azonos évben kiadott könyveket tekintve.</p>
      <p>Összességében: a COUNT-ot leszámítva minden függvényhez egy megfelelő mezőt kell megadni, amin szeretnénk számításokat elvégezni. A GROUP BY-nál meg bizonyos szempontok szerint csoportosítunk.</p>
    </div>

    <div id="adattipusok">
      <h2>Adattípusok áttekintése</h2>
      <p>Újabb adattípusok:</p>
      <ul style="list-style: none;">
        <li>CHAR - karaktertípus, fix memóriafelhasználással</li>
        <li>DECIMAL(x,y) - tizedes tört x számjeggyel, y tizedesjeggyel</li>
        <li>FLOAT - tizedestört, 7 számjegyig jó</li>
        <li>DOUBLE - tizedestört, 15 számjegyig jó</li>
        <li>DATE - dátum 'YYYY-MM-DD'</li>
        <li>TIME - idő 'HH:MM:SS'</li>
        <li>DATETIME - dátum + idő 'YYYY-MM-DD HH:MM:SS'</li>
        <li>TIMESTAMPS - dátum + idő</li>
        <li>CURDATE() - mai dátum</li>
        <li>CURTIME() - pontos idő</li>
        <li>NOW() - mai dátum + pontos idő</li>
        <li>DAY() - nap</li>
        <li>DAYNAME() - nap neve</li>
        <li>DAYOFWEEK() - hányadik nap a héten az adott nap</li>
        <li>DAYOFYEAR() - hányadik nap az évben az adott nap</li>
        <li>MONTH() - hónap</li>
        <li>MONTHNAME() - hónap neve</li>
        <li>YEAR() - év</li>
        <li>HOUR() - óra</li>
        <li>MINUTE() - perc</li>
        <li>SECOND() - másodperc</li>
        <li>DATE_FORMAT() - dátumok visszaadása formázva</li>
        <li>DATEDIFF() - különbség dátumok között</li>
        <li>DATE_ADD() - dátumok összeadása</li>
      </ul>
      <h3>CHAR ÉS VARCHAR</h3>
      <p>Ezek szövegek tárolására alkalmasak, ahol a karakterek hosszának 0 és 255 közötti értéket tudunk megadni. A különbség kettő között az, hogy a CHAR rendelkezik egy fix hosszúsággal. Ez azt jelenti, hogyha mondjuk 5-t adunk meg hosszúságnak, akkor a hosszabb szövegeket levágja, a rövidebb szövegeket pedig szóközökkel egészíti ki. Viszont ha a szöveget le szeretnénk kérdezni, akkor a helykitöltő szóközök eltűnnek. Az előnye: a CHAR-t gyorsabban lehet használni fix hosszúságú szövegekhez. A lényegi különbség a lefoglalt tárhelyekben van: míg a CHAR fix byte-nyi területet foglal el, addig a VARCHAR által felhasznált byte-ok a szöveg méretétől függően változnak (szöveg hossza + 1).</p>
      <p>Éppen ezért a nagyobb adatbázisoknál célszerű VARCHAR-t használni.</p>
      <h3>DECIMAL</h3>
      <p>Tizedestörtek kiíratására alkalmas adattípus. Amikor ezt adjuk meg a mező típusának, akkor 2 paramétert kell neki megadni: az első paraméter a szám hossza (amiben a tizedesvessző előtti és utáni számok is benne vannak!), a második pedig, hogy hány számjegy áll a tizedestört után. Például a DECIMAL(5,2)-nél a 999.99-et még el tudjuk tárolni. Fontos: első számnak 1 és 65, míg a másodiknak 0 és 30 közöttnek kell lennie és a 2. szám nem lehet nagyobb, mint az első (nyilván).</p>
      <p>A tizedesvessző utáni valahány szám akkor is kiírásra kerül, ha nem adjuk meg azokat. Például ha 2. paraméternek 2-t adunk meg, akkor a 7 7.00, míg a 2.1 2.10 formában fog megjelenni.</p>
      <p>Ha túl nagy számot adunk meg, például a DECIMAL(5,2)-nél 7696325-t, akkor 999.99-et kapunk vissza, vagyis a lehető legnagyobb számot, ami megfelel az adattípusnak.</p>
      <p>Ha a tizedesvessző után több számot adunk meg, mint amennyit definiáltunk, akkor automatikusan kerekít a program. Például DECIMAL(5,2)-nál 2.5762 esetén 2.58-t kapunk vissza.</p>
      <h3>FLOAT, DOUBLE</h3>
      <p>Lényegi különbség nincs ekettő és a DECIMAL között, mind a három tizedes törteket tárol. A lényeges különbség a felhasznált memóriában van: a FLOAT és a DOUBLE kevesebb memóriát használ, de ennek ára van, méghozzá az, hogy e kettő adattípus kevésbé precíz.</p>
      <img src="../img/mysql/Kép69.jpg" alt="">
      <p>Ahogy látható is, a FLOAT 7 számjegyet, míg a DOUBLE 15 számjegyet képes precízen tárolni.</p>
      <p>Néhány példa: a FLOAT a 8877665544.45-ből 8877670000-t csinál.</p>
      <p>Szóval inkább célszerűbb DOUBLE-t használni.</p>
      <p>Viszont ha fontos a precizitás, használjunk DECIMALT!</p>
      <h3>DATE, TIME, DATETIME</h3>
      <p>DATE - csak dátumot tároló adattípus. Formátuma: 'YYYY-MM-DD'</p>
      <p>TIME - csak időt tároló adattípus. Formátuma: 'HH:MM:SS'</p>
      <p>DATETIME - dátumot és időt tároló adattípus. Formátuma: 'YYYY-MM-DD HH:MM:SS'</p>
      <p>Például:</p>
      <img src="../img/mysql/Kép70.jpg" alt="">
      <h3>CURDATE, CURTIME, NOW</h3>
      <p>A CURDATE a jelenlegi dátumot, a CURTIME a pontos időt, míg a NOW a jelenlegi dátumot adja vissza a pontos idővel.</p>
      <p>Ezek függvények, így a kulcsszavak után ki kell tenni a ()-t! Lekérdezni a SELECT-tel tudjuk őket.</p>
      <p>Vagy akár be is illeszthetjük a táblába az alábbiak szerint: VALUES ('Most', CURDATE(), CURTIME(), NOW())</p>
      <h3>TIMESTAMPS</h3>
      <p>A TIMESTAMP hasonló típusú, mint a DATETIME, de van néhány különbség közöttük.</p>
      <ol>
        <li>A DATETIME adattípus 1000-01-01 00:00:00 és 9999-12-31 23:59:59 között, míg a TIMESTAMP csak 1970-01-01 00:00:01 és 2038-01-19 03:14:07 között képes dátumot tárolni.</li>
        <li>A DATETIME típusú adatok 8, míg a TIMESTAMP típusúak 4 byte-ot foglalnak el.</li>
      </ol>
      <p>Érdemes akkor használni a TIMESTAMP-et, ha tudjuk, hogy ezen rangen belül tudunk maradni, illetve azt szeretnénk meghatározni, hogy egy meta-adat mikor keletkezett vagy frissült.</p>
      <p>Tudjuk automatikusan is updatelni a megadott időt, ehhez az ON UPDATE CURRENT_TIMESTAMP-re lesz szükségünk. Ekkor minden UPDATE-kor automatikusan felülírásra kerül a dátum a pontos időre.</p>
      <img src="../img/mysql/Kép71.jpg" alt="">
      <p>CURRENT_TIMESTAMP = NOW().</p>
    </div>

    <div id="date-maths">
      <h2>Dátumok formázása és a "dátum matek"</h2>
      <ul style="list-style: none;">
        <li>DAY() - a dátumban szereplő nap (pl 2022-10-11 esetében 11)</li>
        <li>DAYNAME() - az adott nap neve (2022-10-11 esetében kedd)</li>
        <li>DAYOFWEEK() - az adott nap hányadik a héten (2022-10-11 esetében 3)</li>
        <li>DAYOFYEAR() - az adott nap hányadik az évben (2022-10-11 esetében 284)</li>
      </ul>
      <p>Ezeket lekérdezhetjük időre is, csak semmi értelme, ugyanis az idő nem tárol semmilyen információt a napra vonatkozólag!</p>
      <p>Hónapra és évre vonatkozó függvények:</p>
      <ul style="list-style: none;">
        <li>MONTH() - a hónap sorszámát adja vissza</li>
        <li>MONTHNAME() - a hónap nevét adja vissza</li>
        <li>YEAR() - az adott évet adja vissza</li>
      </ul>
      <p>Időre vonatkozó függvények:</p>
      <ul style="list-style: none;">
        <li>HOUR() - az órát adja vissza</li>
        <li>MINUTE() - a percet adja vissza</li>
        <li>SECOND() - a másodpercet adja vissza</li>
      </ul>
      <p><strong>EZEK MIND MŰKÖDNEK DATETIME-RA IS!</strong></p>
      <p>Egyszerűbb megoldás:</p>
      <p>DATE_FORMAT(datum, formatum)</p>
      <p>pl: DATE_FORMAT('2008-02-23', '%Y %M %D)</p>
      <p>DATE_FORMAT(birthdt, 'Was born on a %W')</p>
      <p>DATE_FORMAT(birthdt, '%m/%d/%Y at %H:%i')</p>
      <p>A teljes lista elérhető <a href="https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_date-format">itt.</a></p>
      <h3>Dátum matek: DATEDIFF és DATE_ADD</h3>
      <p>DATEDIFF(datum1, datum2), az eredmény: datum1-datum2 napokban</p>
      <p>DATE_ADD(datum1, INTERVAL expr unit): datum1 + INT unit</p>
      <p>SELECT datum1 + INTERVAL expr unit;</p>
      <p>SELECT datum1 - INTERVAL expr unit;</p>
    </div>

    <div id="logical-operators">
      <h2>Logikai operátorok</h2>
      <ul style="list-style: none;">
        <li>!=</li>
        <li>NOT LIKE</li>
        <li>></li>
        <li>>=</li>
        <li><</li>
        <li><=</li>
        <li>BETWEEN, NOT BETWEEN</li>
        <li>IN, NOT IN</li>
      </ul>
      <h3>Not equal</h3>
      <p class="p-bold">Nem egyenlő.</p>
      <p>Jelölése: !=</p>
      <p>WHERE-ben lévő feltételt tudjuk vele tagadni</p>
      <p>Pl.: WHERE released_year != 2007</p>
      <h3>Not like</h3>
      <p class="p-bold">Jelölése: NOT LIKE</p>
      <p>Azokat a rekordokat kapjuk vissza, amelyek nem illeszkednek az általunk megadott patternra.</p>
      <p>Pl.: WHERE title NOT LIKE "%the%"</p>
      <h3>Greater than</h3>
      <p class="p-bold">Nagyobb mint</p>
      <p>Jelölése: ></p>
      <h3>Greater Than or Equal To</h3>
      <p class="p-bold">Nagyobb vagy egyenlő</p>
      <p>Jelölése: >=</p>
      <p>Azokat a rekordokat kapjuk vissza, amik vagy nagyobbak vagy nagyobb vagy egyenlőek, mint az általunk megadott érték (WHERE-ben).</p>
      <p>Van értelme annak is, ha SELECT után írunk egy összehasonlítást, az eredmény 1, ha igaz és 0, ha hamis (például: 99 > 1, eredmény: 1).</p>
      <p>Nem érzékeny a kis-/nagybetűkre!</p>
      <p>Pl.: WHERE released_year >= 2001</p>
      <h3>Lesser Than</h3>
      <p class="p-bold">Kisebb mint</p>
      <p>Jelölése: <</p>
      <h3>Lesser Than or Equal To</h3>
      <p class="p-bold">Kisebb vagy egyenlő</p>
      <p>Jelölése: <=</p>
      <p>Azokat a rekordokat kapjuk vissza, amik vagy kisebbek vagy kisebb vagy egyenlőek, mint az általunk megadott érték (WHERE-ben).</p>
      <p>Ugyanúgy van értelme összehasonlítást írni a SELECT után, mint a másik esetben.</p>
      <p>Pl.: Stock_quantity <= 100</p>
      <h3>And</h3>
      <p class="p-bold">Logikai és</p>
      <p>Jelölése: AND vagy &&</p>
      <p>Több feltételt tudunk vele összekapcsolni, amelynek az a lényege, hogy csak azokat a rekordokat kapjuk vissza, amelyre az ÖSSZES AND-del összekapcsolt feltétel teljesül.</p>
      <p>Pl.: WHERE released_year > 2000 AND stock_quantity < 50</p>
      <h3>Or</h3>
      <p class="p-bold"> Logikai vagy.</p>
      <p>Jelölése: OR vagy ||</p>
      <p>Több feltételt tudunk vele összekapcsolni, amelynek az a lényege, hogy az összes olyan rekordot visszakapjuk, amelyre teljesül LEGALÁBB EGY feltétel, amiket OR-ral kapcsolunk össze.</p>
      <p>Pl.: WHERE released_year > 2000 OR stock_quantity < 50</p>
      <p><strong>A logikai éssel és vaggyal komplexebb feltételeket is létre tudunk hozni, csak figyelni kell a helyes zárójelezésre!</strong></p>
      <p>1. eset: WHERE (title LIKE '%the%' AND released_year < 2000) OR stock_quantity >= 100;</p>
      <p>(1. feltétel: a könyv címében van 'the' és 2000 előtti <br>
        2. feltétel: raktáron legalább 100 van a könyvből <br>
        Ebből 1-nek kell teljesülnie - eredmény: 7 db könyv)</p>
      <br>
      <p>2. eset: WHERE title LIKE '%the%' AND (released_year < 2000 OR stock_quantity >= 100)</p>
      <p>(Ugyanannak tűnhet, mint az előző, de máshogy van zárójelezve. Itt: <br>
        1. feltétel: a könyv címében van 'the' <br>
        2. feltétel: a könyv 2000 előtti vagy van belőle legalább 100 raktáron <br>
        Itt mindkettőnek teljesülnie kell - eredmény: 2 db könyv)</p>
      <h3>Between</h3>
      <p class="p-bold">Két érték között.</p>
      <p>A BETWEEN kulcsszó után 2 értéket kell megadni AND kulcsszóval elválasztva. Ekkor az összes olyan rekordot visszakapjuk, ami e két érték között található.</p>
      <p>Pl.: WHERE pages BETWEEN 200 AND 500</p>
      <br>
      <p>A párja a NOT BETWEEN, az összes olyan rekordot visszaadja, ami nincs két érték között. Hasonlóan a kulcsszó után két értéket kell megadni, AND kulcsszóval összekötve.</p>
      <p>Pl.: WHERE pages NOT BETWEEN 200 AND 500</p>
      <br>
      <p>Ha dátumokra vagy időre szeretnénk BETWEEN-t alkalmazni, akkor célszerű a CAST() függvény segítségével átalakítani a dátumot DATE, az időt TIME típusra, hogy pontosabb eredményt kapjuk. A CAST() függvény működése: CAST(dátum/idő AS DATE/TIME/DATETIME);</p>
      <p>Pl.: WHERE birthdt BETWEEN CAST('1980-01-01' AS DATETIME) AND CAST('2022-10-12' AS DATETIME);</p>
      <h3>IN, NOT IN</h3>
      <p>Az IN és a NOT IN kulcsszavakhoz egy halmaz tartozik, melynek elemeit kerek zárójelek között kell megadni. Az IN kulcsszó esetében azokat a rekordokat kapjuk vissza, ahol egy adott mező értéke benne van az általunk megadott halmazban. A NOT IN-nel természetesen ennek a komplementerét kapjuk vissza.</p>
      <p>Pl.: WHERE pages IN (208, 790, 400);</p>
      <p>Pl.: WHERE released_year NOT IN (1997, 2001, 2007);</p>
      <br>
      <p>MOD (%) - modulo, osztási maradék vizsgálata (MOD 2 = 0 -> páros valami)</p>
      <p>SELECT title, released_year MOD 2 <br>
        FROM books;</p>
      <br>
      <p>DIV (/) - egészosztás</p>
      <p>SELECT title, released_year DIV 2 <br>
        FROM books;</p>
      <h3>Elágazások</h3>
      <p>Az elágazást a SELECT-en belül alkalmazhatjuk és ideiglenes új oszlopot vagy oszlopokat tudunk vele létrehozni. Az elágazás szintaxisa:</p>
      <img src="../img/mysql/Kép72.jpg" alt="">
      <p>CASE - elágazás kezdete</p>
      <p>WHEN - a feltételünket tudjuk megadni</p>
      <p>THEN - ha teljesül a feltétel, akkor mit kapjunk vissza</p>
      <p>ELSE - ellenkező esetben mit kapunk vissza</p>
      <p>END - milyen nevet kapjon ez az ideiglenes oszlop</p>
      <br>
      <p>Működése: mindig az első feltételt nézi meg, ha nem teljesül, akkor a másodikat nézi meg és így tovább. Amennyiben egyik feltétel sem teljesül, úgy az ELSE ágon lévő értéket fogja felhasználni.</p>
    </div>

    <div id="constraint">
      <h2>Megszorítások (Constraintek) és táblák módosítása</h2>
      <h3>UNIQUE</h3>
      <p>A UNIQUE kulcsszóval azt tudjuk megadni, hogy minden rekordnak az adott mezőhöz tartozó értéke különbözik. Ha valamelyik mezőben duplikált adat található, akkor errort kapunk!</p>
      <img src="../img/mysql/Kép73.jpg" alt="">
      <p>Ebben az esetben a telefonszám minden rekordnál különböző kell, hogy legyen!</p>
      <h3>CHECK</h3>
      <p>A CHECK megadásával azt tudjuk meghatározni, hogy bizonyos mezőbe milyen adatok kerülhetnek. Amennyiben a feltétel nem teljesül, úgy hibaüzenetet kapunk és az adott rekord nem kerül be a táblába.</p>
      <p>Ennél a példánál például, ha kornak 18-at vagy annál kevesebbet adunk meg, hibát kapunk!</p>
      <img src="../img/mysql/Kép74.jpg" alt="">
      <p>Ennél a példánál pedig azt ellenőriztetjük le, hogy az általunk megadott szó palindrom-e.</p>
      <img src="../img/mysql/Kép75.jpg" alt="">
      <h3>Megszorítások elnevezése</h3>
      <p>Megszorításokat az alábbiak szerint tudunk megnevezni: a tábla létrehozásakor az utolsó sor(ok)ban a CONSTRAINT kulccsszó után el kell nevezni a megszorításunkat és meg kell adni magát a megszorítást. Az előző példánál maradva:</p>
      <img src="../img/mysql/Kép76.jpg" alt="">
      <p>A megszorítás elnevezésére azért van szükség, hogy a hibaüzenetnél pontosan lássuk, hogy mi a probléma.</p>
      <h3>Megszorítások több mezőre</h3>
      <p>Ha több mezőre teszünk megszorítást, akkor minden mezőre teljesülnie kell egy feltételnek.</p>
      <p>Ebben a példában a név-cím párosnak egyedinek kell lennie minden sorban. Pontosítva: ugyanaz a név, illetve ugyanaz a cím szepelhet többször a táblában, viszont ugyanaz a név-cím kombináció nem!</p>
      <img src="../img/mysql/Kép77.jpg" alt="">
      <p>Ebben a példában pedig két mező értékét hasonlítjuk össze egymással.</p>
      <img src="../img/mysql/Kép78.jpg" alt="">
      <h3>Táblák módosítása</h3>
      <p>Táblákat az ALTER TABLE kulcsszó segítségével tudunk módosítani. Többféle módosítás lehetséges. Például: Oszlop hozzáadása, illetve elhagyása, átnevezés, oszlopok módosítása illetve megszorítások kötése.</p>
      <h4>Oszlopok hozzáadása</h4>
      <p>Oszlopokat az ADD COLUMN kulccszó után tudunk megadni. A szintaxis megegyezik azzal, mintha a tábla létrehozásakor adnánk meg egy mezőt.</p>
      <p>Szintaxis: <br>
        ALTER TABLE {tabla} <br>
        ADD COLUMN* {oszlop} {opciok}; <br>
        * - opcionális</p>
      <p>Példa: <br>
        ALTER TABLE customers <br>
        ADD COLUMN employee_count INT NOT NULL DEFAULT 1;</p>
      <h4>Oszlopok elhagyása</h4>
      <p>Oszlopokat a DROP COLUMN kulcsszó után tudunk elhagyni. A kulcsszó után csak az elhagyni kívánt oszlop vagy oszlopok nevét kell megadni.</p>
      <p>Szintaxis: <br>
        ALTER TABLE {tabla} <br>
        DROP COLUMN* {oszlop} <br>
        * - opcionális</p>
      <p>Példa: <br>
      ALTER TABLE customers <br>
      DROP COLUMN employee_count;</p>
      <h4>Táblák átnevezése</h4>
      <p>Táblákat kétféleképpen lehet átnevezni:</p>
      <p>1. ALTER TABLE kulcsszó nélkül</p>
      <p>Szintaxis: RENAME TABLE ... TO ...</p>
      <p>Példa: RENAME TABLE companies TO suppliers; - ekkor a companies nevű táblát átnevezzük suppliersre.</p>
      <br>
      <p>2. ALTER TABLE kulcsszóval</p>
      <p>Szintaxis: ALTER TABLE ... RENAME TO ...</p>
      <p>Példa: <br>
        ALTER TABLE companies <br>
        RENAME TO suppliers;</p>
      <h4>Mezők átnevezése</h4>
      <p>Mezőket az ALTER TABLE kulcsszó után megadott RENAME COLUMN ... TO ... kulcsszóval tudjuk átnevezni.</p>
      <p>Szintaxis: <br>
        ALTER TABLE {tabla} <br>
        RENAME COLUMN {oszlop1} TO {oszlop2} <br>
        (ahol oszlop1 a régi, az oszlop2 az új név)</p>
      <p>Például: <br>
        ALTER TABLE suppliers <br>
        RENAME COLUMN name TO biz_name;</p>
      <h4>Oszlopok módosítása</h4>
      <p>Oszlopokat a MODIFY kulccszó után tudunk módosítani. Ezzel az adott oszlopnak a típusát tudjuk megváltoztatni.</p>
      <p>Szintaxis: <br>
        ALTER TABLE {table} <br>
        MODIFY {oszlop} {tipus} {opciok}</p>
      <p>Például: <br>
        ALTER TABLE suppliers <br>
        MODIFY biz_name VARCHAR(100); <br>
        ALTER TABLE suppliers <br>
        MODIFY biz_name VARCHAR(100) NOT NULL DEFAULT 'unknown';</p>
      <br>
      <p>A CHANGE kulcsszóval egyszerre tudjuk megváltoztatni az oszlop nevét ÉS típusát. Ezt ritkábban használjuk.</p>
      <p>Szintaxis: <br>
        ALTER TABLE {tabla} <br>
        CHANGE {oszlop1} {oszlop2} {opciok} <br>
        (ahol oszlop1 a régi, az oszlop2 az új név)</p>
      <p>Példa: <br>
        ALTER TABLE suppliers <br>
        CHANGE business biz_name VARCHAR(50);</p>
      <p>Ez utóbbi példában a 'business' mezőt átneveztük 'biz_name'-re ÉS a típusát megváltoztattuk VARCHAR(50)-re.</p>
      <h3>Megszorítások hozzáadása és elvétele</h3>
      <p>Kezdjük előbb a hozzáadással. Megszorítást hozzáadni a táblához az ADD CONSTRAINT-tel tudunk. Ennek szintaxisa így néz ki:</p>
      <p>ALTER TABLE {tabla} <br>
        ADD CONSTRAINT* {nev}* {megszoritas} <br>
        * - opcionális</p>
      <p>Példa: <br>
        ALTER TABLE houses <br>
        ADD CONSTRAINT positive_pprice CHECK (purchase_price > 0);</p>
      <p>Megszorítást a DROP CONSTRAINT-tel tudunk elhagyni. Míg a megszorítás hozzáadásánál opcionálisan lehetett megadni nevet, az elhagyásnál kötelező lesz megadni a megszorítás nevét.</p>
    </div>

    <div id="kapcsolatok">
      <h2>Kapcsolatok</h2>
      <h3>Kapcsolatok</h3>
      <p>Háromféle különböző kapcsolat van:</p>
      <ol>
        <li>"One to one" kapcsolat</li>
        <li>"One to many" kapcsolat - ez a leggyakoribb</li>
        <li>"Many to many" kapcsolat</li>
      </ol>
      <p>2.-ra jó példa az, hogyha vesszük a Könyvek és az Értékelések táblákat. Minden könyvhöz több értékelés tartozik, de minden értékelés csak 1 könyvhöz tartozik.</p>
      <p>3.-ra jó példa az, hogyha vesszük a Könyvek és a Szerzők táblákat. Vannak olyan könyvek, amikhez több szerző tartozik és vannak olyan szerzők, akik több könyvet is írtak.</p>
      <h3>One-to-many</h3>
      <p>Vegyünk egy klasszikus példát: van egy Vásárlók és egy Rendelések táblánk. Minden vásárló többször is tud rendelni, de minden rendelés csak 1 vásárlóhoz tartozhat. Alapesetben meg tudnánk azt csinálni, hogy az egészhez egy táblát használunk, de több probléma is felmerül: az egyik ilyen probléma az, hogy rengeteg duplikált érték lenne, ha például valaki többször is vásárolt, viszont ha valaki csak beregisztrált, de nem vásárolt, akkor a vásárlás mezőben NULL érték keletkezne.</p>
      <p>Ezt a problémát az alábbiak szerint lehet kiküszöbölni: egy tábla helyett használjunk kettőt: az első tábla tartalmazza a vásárló id-ját, a nevét és az email címét, míg a második tábla tartalmazza a rendelés azonosítóját, a vásárlás idejét, a költséget és a vásárló azonosítóját. Ebben az esetben a két táblát a vásárló id-ja segítségével össze tudjuk kapcsolni, de az adatokat mégis külön táblákban tároljuk, ami az átláthatóságot segíti elő.</p>
      <h3>FOREIGN KEY</h3>
      <p>Egy olyan kulcs, amely egy másik táblában található PRIMARY KEY-re utal</p>
      <p>Az előző példánál a Rendelések táblában a vásárló id-ja egy foreign key, mert a vásárlók táblában a vásárló id-ja egy primary key.</p>
      <p>A foreign key segít megtartani a kapcsolatot több tábla között.</p>
      <p>Szintaktikája: táblázat készítésekor utolsó sorban: FOREIGN KEY(mező) REFERENCES tábla(mező)</p>
      <p>Példa: FOREIGN KEY(student_id) REFERENCES students(id)</p>
      <p>Foreign key-es táblák esetén a törlés fordított sorrendben történik, mint a létrehozás, mivel ahol van foreign key, ott nem törölhetjük ki azt a táblát, amivel kapcsolatban áll!</p>
    </div>

    <div id="joins">
      <h2>JOIN-ok, 1:n kapcsolat</h2>
      <img src="../img/mysql/Kép79.jpg" alt="">
      <h3>1:n kapcsolat</h3>
      <p>A és B tábla között 1:n kapcsolat van, ha az A tábla bármelyik kulcsát a B tábla több rekordjával is tudjuk matchelni, viszont a B tábla bármelyik kulcsa legfeljebb egy darab A táblabeli rekorddal tudjuk párosítani.</p>
      <h3>Cross Join</h3>
      <p>Cross Join - Az A tábla összes rekordját összekötjük a B tábla összes rekordjával, így egy a*b rekordból álló táblát kapunk, ahol 'a' az A, valamint a 'b' a B táblában található rekordok száma.</p>
      <p>SELECT * FROM tablaA, tablaB;</p>
      <h3>LEFT JOIN</h3>
      <p>Amennyiben az A tábla kulcsa közül valamelyik szerepel a B tábla kulcsai között, úgy a B tábla adott rekordját hozzájoinoljuk a táblához.</p>
      <p>Az A tábla összes rekordja mindenképp bekerül a joinolt táblába, míg a B tábla azon rekordjait, amivel nem tudtunk matchelni, elhagyjuk. Lehet benne Null, amit az IFNULL() függvénnyel tudunk "feloldani".</p>
      <p>Pl.: <br>
        A tábla kulcsai - 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 <br>
        B tábla kulcsai - 2, 4, 6, 8, 10, 12, 14, 15 <br>
        Joinolt táblában: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 <br>
        Null érték tartozhat hozzá: 1, 3, 5, 7, 9</p>
      <p>Szintaxis:</p>
      <p>SELECT {mezok} <br>
        FROM tablaA <br>
        LEFT JOIN tablaB <br>
        ON tablaA.key = tablaB.key</p>
      <h3>RIGHT JOIN</h3>
      <p>Amennyiben a B tábla kulcsa közül valamelyik szerepel az A tábla kulcsai között, úgy az A tábla adott rekordját hozzájoinoljuk a táblához.</p>
      <p>A B tábla összes rekordja mindenképp bekerül a joinolt táblába, míg az A tábla azon rekordjait, amivel nem tudtunk matchelni, elhagyjuk. Lehet benne Null, amit az IFNULL() függvénnyel tudunk "feloldani".</p>
      <p>Pl.: <br>
        A tábla kulcsai - 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 <br>
        B tábla kulcsai - 2, 4, 6, 8, 10, 12, 14, 15 <br>
        Joinolt táblában: 2, 4, 6, 8, 10, 12, 14, 15 <br>
        Null érték tartozhat hozzá: 12, 14, 15</p>
      <p>Szintaxis:</p>
      <p>SELECT {mezok} <br>
        FROM tablaA <br>
        RIGHT JOIN tablaB <br>
        ON tablaA.key = tablaB.key</p>
      <h3>INNER JOIN</h3>
      <p>Az A és a B tábla azon rekordjai szerepelnek az összekapcsolt táblában, amelynek kulcsai az A és a B táblában is szerepelnek. Ez az egyetlen join, ahol nem lesz null érték (hacsak nem adtunk meg az egyik táblában null értéket).</p>
      <p>Pl.: <br>
        A tábla kulcsai - 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 <br>
        B tábla kulcsai - 2, 4, 6, 8, 10, 12, 14, 15 <br>
        Joinolt táblában: 2, 4, 6, 8, 10 <br>
        Null érték tartozhat hozzá: -</p>
      <p>Szintaxis:</p>
      <p>SELECT {mezok} <br>
        FROM tablaA <br>
        INNER JOIN tablaB <br>
        ON tablaA.key = tablaB.key</p>
      <br>
      <p>Implicit inner join - Cross join feltétellel <br>
        SELECT {mezok} <br>
        FROM tablaA, tablaB <br>
        WHERE tablaA.key = tablaB.key;</p>
      <br>
      <p>Explicit inner join - az INNER JOIN helyett JOIN van <br>
        SELECT {mezok} <br>
        FROM tablaA <br>
        JOIN tablaB <br>
        ON tablaA.key = tablaB.key;</p>
      <h3>OUTER JOIN</h3>
      <p>Az A és a B tábla összes rekordjai szerepelnek az összekapcsolt táblában, amelynek kulcsai az A vagy a B táblában szerepelnek. Azoknál a rekordoknál, amelyek eltérnek, null érték(ek) keletkeznek.</p>
      <p>Pl.: <br>
        A tábla kulcsai - 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 <br>
        B tábla kulcsai - 2, 4, 6, 8, 10, 12, 14, 15 <br>
        Joinolt táblában: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15 <br>
        Null érték tartozhat hozzá: 1, 3, 5, 7, 9, 12, 14, 15</p>
      <p>Szintaxis:</p>
      <p>SELECT {mezok} <br>
        FROM tablaA <br>
        FULL OUTER JOIN tablaB <br>
        ON tablaA.key = tablaB.key</p>
      <br>
      <p>Több összejoinolt tábla esetén kétféleképp hivatkozhatunk mezőre:</p>
      <ol>
        <li>Ha a mező neve egyedi, akkor simán a mező nevét adjuk meg</li>
        <li>Ha az adott mező neve többször is előfordul, akkor a táblával tudunk hivatkozni a megfelelő mezőre: tabla.mezo. Pl.: konyveim.id</li>
      </ol>
      <br>
      <p>ON DELETE CASCADE - Ezt a FOREIGN KEY-nél tudjuk megadni és a célja az, hogyha egy rekordot törlünk a szülő táblában, akkor a gyerek táblában az összes hozzá tartozó rekordot töröljük, ugyanis azokra a rekordokra így már nem lesz szükségünk.</p>
    </div>

    <div id="nn">
      <h2>n:n kapcsolat</h2>
      <p>A és B tábla között n:n kapcsolat van, ha az A tábla bármelyik kulcsát a B tábla több rekordjával is matchelhetjük, illetve a B tábla bármelyik kulcsát több A táblabeli rekorddal tudjuk párosítani. Az A és B tábla között ilyenkor egy kötőtábla található.</p>
    </div>

    <div id="views">
      <h2>Táblák létrehozása (views)</h2>
      <h3>Virtuális táblák létrehozása</h3>
      <p>A CREATE VIEW {tabla} AS {lekerdezes} utasítással el tudjuk menteni az általunk megadott lekérdezés után kapott táblát. Ennek célja az, hogy bizonyos esetekben nem kell mégegyszer a lekérdezést megírni, hanem, mivel az elmentett tábla is normális táblaként funkcionál, könnyen hozzá tudunk férni az adott táblához és ugyanúgy tudunk lekérdezéseket is írni vele.</p>
      <p>Pl.: CREATE VIEW full_reviews AS <br>
        SELECT title, released_year, genre, rating, first_name, last_name FROM reviews <br>
        JOIN series ON series.id = reviews.series_id <br>
        JOIN reviewers ON reviewers.id = reviews.reviewer_id;</p>
      <p>Ezután a full_reviews virtuális táblaként fog viselkedni.</p>
      <p>Ahhoz, hogy egy ilyen táblát frissíteni tudjunk, számos feltételt figyelembe kell vennünk, amikor létrehozunk egy nézetet. A teljes lista megtalálható <a href="https://dev.mysql.com/doc/refman/8.0/en/view-updatability.html">itt</a>. </p>
      <p>Ha valamelyik feltétel teljesül, amikor létrehozzuk a virtuális táblát, akkor azt már nem tudjuk módosítani, mert hibaüzenetet kapunk.</p>
      <p>Ha esetleg módosítani szeretnénk a táblán, például rossz sorrendben rendeztük, akkor használjuk a CREATE OR REPLACE VIEW {tabla} As {lekerdezes} utasítást (vagy az ALTER VIEW {tabla} AS {lekerdezes}-t)! Ekkor, ha létezik az adott néven található virtuális tábla, akkor lecserélődik.</p>
      <h3>HAVING</h3>
      <p>A HAVING segítségével a csoportosított adatainkat tudjuk szűrni. Ha például olyan lekérdezést írunk, hogy</p>
      <p>SELECT released_year, SUM(pages) <br>
        FROM books <br>
        GROUP BY released_year <br>
        HAVING SUM(pages) > 500;</p>
      <p>akkor csak azokat a csoportokat fogjuk visszakapni, ahol az összoldalszám legalább 500. A HAVING mindig a GROUP BY után áll!</p>
      <h3>WITH ROLLUP</h3>
      <p>A WITH ROLLUP kulcsszó a GROUP BY-jal áll együtt és ennek segítségével a lekérdezés során kapott táblázat utolsó sorában megjelenik egy összegző sor.</p>
      <p>Például, ha értékeléseket címek szerint csoportosítunk és ezeket összeszámoljuk a COUNT() függvény segítségével, akkor a WITH ROLLUP megadásával a lekérdezés során kapunk egy új sort, ahol meglátjuk, hogy összesen hány értékelésünk van.</p>
      <p>Vagy szintén, ha az értékeléseket műfajok szerint csoportosítunk és az egyes műfajok értékeléseit átlagoljuk az AVG() függvény segítségével, akkor az utolsó sorban az összes értékelés átlagát kapjuk meg a WITH ROLLUP megadásával.</p>
      <p>Pl.:</p>
      <img src="../img/mysql/Kép80.jpg" alt="">
      <p>Működik a WITH ROLLUP akkor is, amikor több mező szerint csoportosítunk. Ha például sorozatokat megjelenési év, valamint műfaj szerint csoportosítjuk (és kiváncsiak vagyunk az adott évbeli és műfajbeli sorozatok értékelésének átlagára), akkor megkapjuk a megjelenési év-műfaj páros értékelésének az átlagát, valamint egy összegző sort, hogy az egyes évbeli sorozatoknak milyen volt az átlagos értékelése (és természetesen a táblázat végén ugyanúgy találunk teljes táblára vonatkozó összesítést).</p>
      <img src="../img/mysql/Kép81.jpg" alt="">
    </div>

    <div id="modes">
      <h2>Különböző módok (modes)</h2>
      <p>Jelenleg használt mód:</p>
      <ol>
        <li>SELECT @@GLOBAL.sql_mode; -- globális</li>
        <li>SELECT @@SESSION.sql_mode; -- session (újraindításkor resetelődik a globalra)</li>
      </ol>
      <p>Módok megadása:</p>
      <ol>
        <li>SET GLOBAL sql_mode = 'modes';</li>
        <li>SET SESSION sql_mode = 'modes';</li>
      </ol>
      <p>Ha valamelyik módot el szeretnénk hagyni, akkor előbb kérdezzük le az aktuálisan használt módokat és adjuk meg az sql_mode-ot anélkül a mód nélkül!</p>
      <p>Legfontosabb mód: STRICT_TRANS_TABLES, amelynek bekapcsolása szükséges ahhoz, hogy ne tudjunk rossz típusosztályú adatot megadni (például stringet abba a mezőbe, ahová az SQL intet vár). Ha kikapcsoljuk, akkor tetszőleges típusú adatokat tudunk megadni bármely mezőhöz, bár ilyen esetekben figyelmeztetést kapunk. Ez utóbbi esetben természetesen nem kerül be ilyen formában az általunk megadott adat: ha például int helyett stringet adunk meg, akkor 0 fog bekerülni a táblába.</p>
      <p>Egyéb módok:</p>
      <p>1. ONLY_FULL_GROUP_BY - hibát kapunk, ha olyan oszlopot szeretnénk lekérdezni, ami vagy nem összevonó függvény vagy nem aszerint csoportosítunk</p>
      <p>Például: <br>
        SELECT title, rating FROM series <br>
        JOIN reviews ON reviews.series_id = series.id <br>
        GROUP BY title;</p> <br>
      <p>Ebben az esetben hibát kapunk, ugyanis a rating nem összevonó függvény (az AVG(rating) már az), valamint a rating szerint nem csoportosítottunk.</p>
      <p>2. NO_ZERO_IN_DATE</p>
      <ul style="list-style: circle;">
        <li>ha ki van kapcsolva, akkor az évhez, a hónaphoz és/vagy a naphoz gond nélkül írhatunk 0-t</li>
        <li>ha be van kapcsolva, akkor az évhez, a hónaphoz és/vagy a naphoz nullát írunk, akkor figyelmeztetést kapunk és a '0000-00-00' dátumot kapjuk vissza</li>
        <li>ha viszont be van kapcsolva ez a mód és be van kapcsolva egy strict mód (pl. STRICT_TRANS_TABLES), akkor hibaüzenetet kapunk</li>
      </ul>
    </div>
    
    <div id="windowfunctions">
      <h2>Ablakfüggvények</h2>
      <p>Az ablakfüggvények segítségével összesítő (aggregate) függvények eredményeit tudjuk megjeleníteni a lekérdezésünk összes soránál. Hasonlít ahhoz, amit korábban láttunk a GROUP BY-nál, de az újdonság az, hogy a lekérdezés minden egyes sorához hozzá tudjuk rendelni az összesítő függvény eredményét (korábban ehhez több lekérdezésre volt szükség).</p>
      <p>Vegyük például a könyveket és meg szeretnénk mondani azt, hogy összesen hány oldalnyi könyv tartozik egy adott műfajhoz. Ha ezt GROUP BY-jal valósítjuk meg, akkor csak a lekérdezés végén megkapjuk a műfajt és a hozzá tartozó össz oldalszámot. Viszont ha ablakfüggvényt kapunk, akkor le tudjuk kérdezni az összes könyvet az adatbázisban és ebben az esetben egy új mezőben megkapjuk azt, hogy mennyi az össz oldalszáma az adott műfajnak.</p>
      <h3>OVER()</h3>
      <p>Az OVER() függvény meghívásával tudjuk megvalósítani azt, hogy minden egyes sornál megjelenjen az összesítő függvény által számolt érték. Ha a zárójelek közé nem írunk semmit, akkor minden sornál ugyanaz az érték jelenik meg.</p>
      <h3>PARTITION BY</h3>
      <p>AZ OVER() függvényt kell hozzá meghívni és a zárójel pár közé kell írni ezt a kulcsszót. A szerepe hasonlít a GROUP BY-éhoz, különböző sorokat tudunk csoportosítani az adott mezőben található értékeik szerint.</p>
      <h3>ORDER BY</h3>
      <p>Az OVER() függvényt kell hozzá meghívni és a zárójel pár közé kell írni ezt a kulcsszót. A működése nem hasonlít a korábban látott ORDER BY-éhoz.</p>
      <p>A működését könnyebb egy példán érzékeltetni: <br>
        Vegyük a könyveket. Ha azt adjuk meg, hogy SUM(oldalszam) OVER(ORDER BY id) AS ossz_oldalszam, akkor a következő történik: <br>
        0. az ossz_oldalszam 0-ról indul <br>
        1. az ossz_oldalszamhoz hozzáadjuk az 1. könyv oldalszámát és az aktuális össz oldalszám jelenik meg az 1. könyvhöz tartozó sorban <br>
        2. ehhez az ossz_oldalszamhoz hozzáadjuk a 2. könyv oldalszámát és az aktuális össz oldalszám (azaz az 1. és a 2. könyv oldalszámának az összege) jelenik meg a 2. könyvhöz tartozó sorban <br>
        és így tovább...</p>
      <p>Tehát ha az ORDER BY-t alkalmazzuk, akkor lépésről-lépésre alkalmazzuk az összesítő függvényt és az összesítő függvény alkalmazásának sorrendjét határozzuk meg vele.</p>
      <p>Példa: <br>
        SELECT id, cim, oldalszam, SUM(oldalszam) OVER(ORDER BY id) AS sum_pages_total <br>
        FROM konyveim;</p>
      <h3>RANK()</h3>
      <p>A RANK() egy tényleges ablakfüggvény, amelynek segítségével rangsorolni tudjuk az adatainkat. Az OVER()-ben meg kell adni azt, hogy mi szerint szeretnénk rangsorolni. Fontos, hogy számít az, hogyha az adott értékek egyenlőek, ilyenkor ugyanolyan sorszámmal látja el az azonos értékkel rendelkező sorokat, illetve ha például 3 darab 40. helyezett van, akkor az utánuk következő a 43. helyezett lesz.</p>
      <p>Példa: <br>
        SELECT id, cim, oldalszam, RANK() OVER(ORDER BY oldalszam DESC) AS ranking <br>
        FROM konyveim;</p>
      <h3>ROW_NUMBER()</h3>
      <p>A sorokat sorszámozza, nem törődik azzal, ha több adat is megegyezik egymással.</p>
      <h3>DENSE_RANK()</h3>
      <p>Hasonlít a RANK()-hez, annyi a különbség, hogyha például 3 darab 40. helyezett van egy adott érték szerint az táblában, akkor a következő nem 43., hanem 41. helyezett lesz, tehát folyamatosan sorszámoz az egyenlőséget figyelembe véve.</p>
      <h3>NTILE(N)</h3>
      <p>Az adatokat N részre osztjuk bizonyos értékek szerint és azt kapjuk vissza minden sornál, hogy melyik részhez tartozik az adott adat az adott érték szerint.</p>
      <p>Például, ha N=4 és az oldalszámokat szeretnénk négyfelé osztani, akkor megkapjuk, hogy az adott könyv a hossza alapján melyik negyedben található, amellyel össze tudjuk hasonlítani, hogy egyes könyvek milyen hosszúak az egészhez képest.</p>
      <p>Példa: <br>
        SELECT id, cim, oldalszam, NTILE(4) OVER(ORDER BY oldalszam) AS negyedek <br>
        FROM konyveim <br>
        ORDER BY id; <br>
        </p>
      <p>Vagy ha például N=100, akkor meg lehet mondani körülbelülre, hogy a könyvek hány százaléka hosszabb, mint az adott könyv.</p>
      <p>Példa: <br>
        SELECT id, cim, oldalszam, NTILE(100) OVER(ORDER BY oldalszam DESC) AS százalék <br>
        FROM konyveim <br>
        ORDER BY id;</p>
      <h3>FIRST_VALUE(), NTH_VALUE()</h3>
      <p>Első és valahányadik érték</p>
      <h3>LAG()</h3>
      <p>Összehasonlítás az előző sor értékével.</p>
      <h3>LEAD()</h3>
      <p>Összehasonlítás a következő sor értékével.</p>
    </div>
    
  </div>
    
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>
  <script src="index.js"></script>

</body>
</html>